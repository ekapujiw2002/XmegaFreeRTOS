
XmegaFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e22  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00802000  00000e22  00000eb6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003af  0080200e  0080200e  00000ec4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ec4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000ef4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002c8  00000000  00000000  00000f34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003d1a  00000000  00000000  000011fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a80  00000000  00000000  00004f16  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000010b5  00000000  00000000  00005996  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006dc  00000000  00000000  00006a4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000018a4  00000000  00000000  00007128  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000020ea  00000000  00000000  000089cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002c8  00000000  00000000  0000aab6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 06 01 	jmp	0x20c	; 0x20c <__ctors_end>
   4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
   8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
   c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  10:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  14:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  18:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  1c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  20:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  24:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  28:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  2c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  30:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  34:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  38:	0c 94 18 03 	jmp	0x630	; 0x630 <__vector_14>
  3c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  40:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  44:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  48:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  4c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  50:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  54:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  58:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  5c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  60:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  64:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  68:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  6c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  70:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  74:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  78:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  7c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  80:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  84:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  88:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  8c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  90:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  94:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  98:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  9c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  ec:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  fc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 100:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 104:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 108:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 10c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 110:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 114:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 118:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 11c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 120:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 124:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 128:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 12c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 130:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 134:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 138:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 13c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 140:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 144:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 148:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 14c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 150:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 154:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 158:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 15c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 160:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 164:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 168:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 16c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 170:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 174:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 178:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 17c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 180:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 184:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 188:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 18c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 190:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 194:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 198:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 19c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1ec:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

000001fc <__trampolines_start>:
 1fc:	0c 94 ba 06 	jmp	0xd74	; 0xd74 <thread_2>
 200:	0c 94 ce 06 	jmp	0xd9c	; 0xd9c <thread_3>
 204:	0c 94 5d 03 	jmp	0x6ba	; 0x6ba <prvIdleTask>
 208:	0c 94 a6 06 	jmp	0xd4c	; 0xd4c <thread_1>

0000020c <__ctors_end>:
 20c:	11 24       	eor	r1, r1
 20e:	1f be       	out	0x3f, r1	; 63
 210:	cf ef       	ldi	r28, 0xFF	; 255
 212:	cd bf       	out	0x3d, r28	; 61
 214:	df e9       	ldi	r29, 0x9F	; 159
 216:	de bf       	out	0x3e, r29	; 62
 218:	00 e0       	ldi	r16, 0x00	; 0
 21a:	0c bf       	out	0x3c, r16	; 60

0000021c <__do_copy_data>:
 21c:	10 e2       	ldi	r17, 0x20	; 32
 21e:	a0 e0       	ldi	r26, 0x00	; 0
 220:	b0 e2       	ldi	r27, 0x20	; 32
 222:	e2 e2       	ldi	r30, 0x22	; 34
 224:	fe e0       	ldi	r31, 0x0E	; 14
 226:	00 e0       	ldi	r16, 0x00	; 0
 228:	0b bf       	out	0x3b, r16	; 59
 22a:	02 c0       	rjmp	.+4      	; 0x230 <__do_copy_data+0x14>
 22c:	07 90       	elpm	r0, Z+
 22e:	0d 92       	st	X+, r0
 230:	ae 30       	cpi	r26, 0x0E	; 14
 232:	b1 07       	cpc	r27, r17
 234:	d9 f7       	brne	.-10     	; 0x22c <__do_copy_data+0x10>

00000236 <__do_clear_bss>:
 236:	23 e2       	ldi	r18, 0x23	; 35
 238:	ae e0       	ldi	r26, 0x0E	; 14
 23a:	b0 e2       	ldi	r27, 0x20	; 32
 23c:	01 c0       	rjmp	.+2      	; 0x240 <.do_clear_bss_start>

0000023e <.do_clear_bss_loop>:
 23e:	1d 92       	st	X+, r1

00000240 <.do_clear_bss_start>:
 240:	ad 3b       	cpi	r26, 0xBD	; 189
 242:	b2 07       	cpc	r27, r18
 244:	e1 f7       	brne	.-8      	; 0x23e <.do_clear_bss_loop>
 246:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <main>
 24a:	0c 94 0f 07 	jmp	0xe1e	; 0xe1e <_exit>

0000024e <__bad_interrupt>:
 24e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000252 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 252:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 254:	03 96       	adiw	r24, 0x03	; 3
 256:	81 83       	std	Z+1, r24	; 0x01
 258:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 25a:	2f ef       	ldi	r18, 0xFF	; 255
 25c:	3f ef       	ldi	r19, 0xFF	; 255
 25e:	23 83       	std	Z+3, r18	; 0x03
 260:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 262:	85 83       	std	Z+5, r24	; 0x05
 264:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 266:	87 83       	std	Z+7, r24	; 0x07
 268:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 26a:	10 82       	st	Z, r1
 26c:	08 95       	ret

0000026e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 26e:	fc 01       	movw	r30, r24
 270:	10 86       	std	Z+8, r1	; 0x08
 272:	11 86       	std	Z+9, r1	; 0x09
 274:	08 95       	ret

00000276 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
 27a:	9c 01       	movw	r18, r24
 27c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 27e:	dc 01       	movw	r26, r24
 280:	11 96       	adiw	r26, 0x01	; 1
 282:	cd 91       	ld	r28, X+
 284:	dc 91       	ld	r29, X
 286:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 288:	c2 83       	std	Z+2, r28	; 0x02
 28a:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 28c:	8c 81       	ldd	r24, Y+4	; 0x04
 28e:	9d 81       	ldd	r25, Y+5	; 0x05
 290:	84 83       	std	Z+4, r24	; 0x04
 292:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 294:	8c 81       	ldd	r24, Y+4	; 0x04
 296:	9d 81       	ldd	r25, Y+5	; 0x05
 298:	dc 01       	movw	r26, r24
 29a:	12 96       	adiw	r26, 0x02	; 2
 29c:	6d 93       	st	X+, r22
 29e:	7c 93       	st	X, r23
 2a0:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
 2a2:	6c 83       	std	Y+4, r22	; 0x04
 2a4:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2a6:	20 87       	std	Z+8, r18	; 0x08
 2a8:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
 2aa:	f9 01       	movw	r30, r18
 2ac:	80 81       	ld	r24, Z
 2ae:	8f 5f       	subi	r24, 0xFF	; 255
 2b0:	80 83       	st	Z, r24
}
 2b2:	df 91       	pop	r29
 2b4:	cf 91       	pop	r28
 2b6:	08 95       	ret

000002b8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 2b8:	cf 93       	push	r28
 2ba:	df 93       	push	r29
 2bc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 2be:	48 81       	ld	r20, Y
 2c0:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 2c2:	4f 3f       	cpi	r20, 0xFF	; 255
 2c4:	2f ef       	ldi	r18, 0xFF	; 255
 2c6:	52 07       	cpc	r21, r18
 2c8:	21 f4       	brne	.+8      	; 0x2d2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 2ca:	fc 01       	movw	r30, r24
 2cc:	a7 81       	ldd	r26, Z+7	; 0x07
 2ce:	b0 85       	ldd	r27, Z+8	; 0x08
 2d0:	0d c0       	rjmp	.+26     	; 0x2ec <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2d2:	dc 01       	movw	r26, r24
 2d4:	13 96       	adiw	r26, 0x03	; 3
 2d6:	01 c0       	rjmp	.+2      	; 0x2da <vListInsert+0x22>
 2d8:	df 01       	movw	r26, r30
 2da:	12 96       	adiw	r26, 0x02	; 2
 2dc:	ed 91       	ld	r30, X+
 2de:	fc 91       	ld	r31, X
 2e0:	13 97       	sbiw	r26, 0x03	; 3
 2e2:	20 81       	ld	r18, Z
 2e4:	31 81       	ldd	r19, Z+1	; 0x01
 2e6:	42 17       	cp	r20, r18
 2e8:	53 07       	cpc	r21, r19
 2ea:	b0 f7       	brcc	.-20     	; 0x2d8 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2ec:	12 96       	adiw	r26, 0x02	; 2
 2ee:	ed 91       	ld	r30, X+
 2f0:	fc 91       	ld	r31, X
 2f2:	13 97       	sbiw	r26, 0x03	; 3
 2f4:	ea 83       	std	Y+2, r30	; 0x02
 2f6:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 2f8:	c4 83       	std	Z+4, r28	; 0x04
 2fa:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
 2fc:	ac 83       	std	Y+4, r26	; 0x04
 2fe:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
 300:	12 96       	adiw	r26, 0x02	; 2
 302:	cd 93       	st	X+, r28
 304:	dc 93       	st	X, r29
 306:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 308:	88 87       	std	Y+8, r24	; 0x08
 30a:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
 30c:	fc 01       	movw	r30, r24
 30e:	20 81       	ld	r18, Z
 310:	2f 5f       	subi	r18, 0xFF	; 255
 312:	20 83       	st	Z, r18
}
 314:	df 91       	pop	r29
 316:	cf 91       	pop	r28
 318:	08 95       	ret

0000031a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 31a:	cf 93       	push	r28
 31c:	df 93       	push	r29
 31e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 320:	a0 85       	ldd	r26, Z+8	; 0x08
 322:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 324:	c2 81       	ldd	r28, Z+2	; 0x02
 326:	d3 81       	ldd	r29, Z+3	; 0x03
 328:	84 81       	ldd	r24, Z+4	; 0x04
 32a:	95 81       	ldd	r25, Z+5	; 0x05
 32c:	8c 83       	std	Y+4, r24	; 0x04
 32e:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 330:	c4 81       	ldd	r28, Z+4	; 0x04
 332:	d5 81       	ldd	r29, Z+5	; 0x05
 334:	82 81       	ldd	r24, Z+2	; 0x02
 336:	93 81       	ldd	r25, Z+3	; 0x03
 338:	8a 83       	std	Y+2, r24	; 0x02
 33a:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 33c:	11 96       	adiw	r26, 0x01	; 1
 33e:	cd 91       	ld	r28, X+
 340:	dc 91       	ld	r29, X
 342:	12 97       	sbiw	r26, 0x02	; 2
 344:	ce 17       	cp	r28, r30
 346:	df 07       	cpc	r29, r31
 348:	31 f4       	brne	.+12     	; 0x356 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 34a:	8c 81       	ldd	r24, Y+4	; 0x04
 34c:	9d 81       	ldd	r25, Y+5	; 0x05
 34e:	11 96       	adiw	r26, 0x01	; 1
 350:	8d 93       	st	X+, r24
 352:	9c 93       	st	X, r25
 354:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 356:	10 86       	std	Z+8, r1	; 0x08
 358:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
 35a:	8c 91       	ld	r24, X
 35c:	81 50       	subi	r24, 0x01	; 1
 35e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 360:	df 91       	pop	r29
 362:	cf 91       	pop	r28
 364:	08 95       	ret

00000366 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 366:	31 e1       	ldi	r19, 0x11	; 17
 368:	fc 01       	movw	r30, r24
 36a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	22 e2       	ldi	r18, 0x22	; 34
 370:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	a3 e3       	ldi	r26, 0x33	; 51
 376:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 37c:	31 97       	sbiw	r30, 0x01	; 1
 37e:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__
	*pxTopOfStack = (portSTACK_TYPE ) 0;
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 384:	31 97       	sbiw	r30, 0x01	; 1
 386:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 388:	31 97       	sbiw	r30, 0x01	; 1
 38a:	60 e8       	ldi	r22, 0x80	; 128
 38c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	62 e0       	ldi	r22, 0x02	; 2
 396:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	63 e0       	ldi	r22, 0x03	; 3
 39c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	64 e0       	ldi	r22, 0x04	; 4
 3a2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	65 e0       	ldi	r22, 0x05	; 5
 3a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 3aa:	31 97       	sbiw	r30, 0x01	; 1
 3ac:	66 e0       	ldi	r22, 0x06	; 6
 3ae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 3b0:	31 97       	sbiw	r30, 0x01	; 1
 3b2:	67 e0       	ldi	r22, 0x07	; 7
 3b4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 3b6:	31 97       	sbiw	r30, 0x01	; 1
 3b8:	68 e0       	ldi	r22, 0x08	; 8
 3ba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 3bc:	31 97       	sbiw	r30, 0x01	; 1
 3be:	69 e0       	ldi	r22, 0x09	; 9
 3c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 3c2:	31 97       	sbiw	r30, 0x01	; 1
 3c4:	60 e1       	ldi	r22, 0x10	; 16
 3c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 3cc:	31 97       	sbiw	r30, 0x01	; 1
 3ce:	32 e1       	ldi	r19, 0x12	; 18
 3d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 3d2:	31 97       	sbiw	r30, 0x01	; 1
 3d4:	33 e1       	ldi	r19, 0x13	; 19
 3d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	34 e1       	ldi	r19, 0x14	; 20
 3dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 3de:	31 97       	sbiw	r30, 0x01	; 1
 3e0:	35 e1       	ldi	r19, 0x15	; 21
 3e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 3e4:	31 97       	sbiw	r30, 0x01	; 1
 3e6:	36 e1       	ldi	r19, 0x16	; 22
 3e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	37 e1       	ldi	r19, 0x17	; 23
 3ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 3f0:	31 97       	sbiw	r30, 0x01	; 1
 3f2:	38 e1       	ldi	r19, 0x18	; 24
 3f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 3f6:	31 97       	sbiw	r30, 0x01	; 1
 3f8:	39 e1       	ldi	r19, 0x19	; 25
 3fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 3fc:	31 97       	sbiw	r30, 0x01	; 1
 3fe:	30 e2       	ldi	r19, 0x20	; 32
 400:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 402:	31 97       	sbiw	r30, 0x01	; 1
 404:	31 e2       	ldi	r19, 0x21	; 33
 406:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 408:	31 97       	sbiw	r30, 0x01	; 1
 40a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 40c:	31 97       	sbiw	r30, 0x01	; 1
 40e:	23 e2       	ldi	r18, 0x23	; 35
 410:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 412:	31 97       	sbiw	r30, 0x01	; 1
 414:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 416:	31 97       	sbiw	r30, 0x01	; 1
 418:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 41a:	31 97       	sbiw	r30, 0x01	; 1
 41c:	26 e2       	ldi	r18, 0x26	; 38
 41e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 420:	31 97       	sbiw	r30, 0x01	; 1
 422:	27 e2       	ldi	r18, 0x27	; 39
 424:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 426:	31 97       	sbiw	r30, 0x01	; 1
 428:	28 e2       	ldi	r18, 0x28	; 40
 42a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 42c:	31 97       	sbiw	r30, 0x01	; 1
 42e:	29 e2       	ldi	r18, 0x29	; 41
 430:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 432:	31 97       	sbiw	r30, 0x01	; 1
 434:	20 e3       	ldi	r18, 0x30	; 48
 436:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 438:	31 97       	sbiw	r30, 0x01	; 1
 43a:	21 e3       	ldi	r18, 0x31	; 49
 43c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 43e:	87 97       	sbiw	r24, 0x27	; 39
 440:	08 95       	ret

00000442 <xPortStartScheduler>:
static void prvSetupTimerInterrupt( void )
{
    //Use TCC0 as a tick counter. If this is to be changed, change ISR as well
    TC0_t * tickTimer = &TCC0;
    //select the clock source and pre-scale by 64
    TC0_ConfigClockSource(tickTimer, TC_CLKSEL_DIV64_gc);
 442:	65 e0       	ldi	r22, 0x05	; 5
 444:	80 e0       	ldi	r24, 0x00	; 0
 446:	98 e0       	ldi	r25, 0x08	; 8
 448:	0e 94 1b 03 	call	0x636	; 0x636 <TC0_ConfigClockSource>
    //set period of counter
    tickTimer->PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 64 - 1;
 44c:	8e e1       	ldi	r24, 0x1E	; 30
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	80 93 26 08 	sts	0x0826, r24
 454:	90 93 27 08 	sts	0x0827, r25

    //enable interrupt and set low level
    TC0_SetOverflowIntLevel(tickTimer, TC_OVFINTLVL_LO_gc);
 458:	61 e0       	ldi	r22, 0x01	; 1
 45a:	80 e0       	ldi	r24, 0x00	; 0
 45c:	98 e0       	ldi	r25, 0x08	; 8
 45e:	0e 94 21 03 	call	0x642	; 0x642 <TC0_SetOverflowIntLevel>
    //enable low level interrupts
    PMIC_EnableLowLevel();
 462:	e0 ea       	ldi	r30, 0xA0	; 160
 464:	f0 e0       	ldi	r31, 0x00	; 0
 466:	82 81       	ldd	r24, Z+2	; 0x02
 468:	81 60       	ori	r24, 0x01	; 1
 46a:	82 83       	std	Z+2, r24	; 0x02
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 46c:	a0 91 b5 23 	lds	r26, 0x23B5
 470:	b0 91 b6 23 	lds	r27, 0x23B6
 474:	cd 91       	ld	r28, X+
 476:	cd bf       	out	0x3d, r28	; 61
 478:	dd 91       	ld	r29, X+
 47a:	de bf       	out	0x3e, r29	; 62
 47c:	ff 91       	pop	r31
 47e:	ef 91       	pop	r30
 480:	df 91       	pop	r29
 482:	cf 91       	pop	r28
 484:	bf 91       	pop	r27
 486:	af 91       	pop	r26
 488:	9f 91       	pop	r25
 48a:	8f 91       	pop	r24
 48c:	7f 91       	pop	r23
 48e:	6f 91       	pop	r22
 490:	5f 91       	pop	r21
 492:	4f 91       	pop	r20
 494:	3f 91       	pop	r19
 496:	2f 91       	pop	r18
 498:	1f 91       	pop	r17
 49a:	0f 91       	pop	r16
 49c:	ff 90       	pop	r15
 49e:	ef 90       	pop	r14
 4a0:	df 90       	pop	r13
 4a2:	cf 90       	pop	r12
 4a4:	bf 90       	pop	r11
 4a6:	af 90       	pop	r10
 4a8:	9f 90       	pop	r9
 4aa:	8f 90       	pop	r8
 4ac:	7f 90       	pop	r7
 4ae:	6f 90       	pop	r6
 4b0:	5f 90       	pop	r5
 4b2:	4f 90       	pop	r4
 4b4:	3f 90       	pop	r3
 4b6:	2f 90       	pop	r2
 4b8:	1f 90       	pop	r1
 4ba:	0f 90       	pop	r0
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 4c0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 4c2:	81 e0       	ldi	r24, 0x01	; 1
 4c4:	08 95       	ret

000004c6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 4c6:	0f 92       	push	r0
 4c8:	0f b6       	in	r0, 0x3f	; 63
 4ca:	f8 94       	cli
 4cc:	0f 92       	push	r0
 4ce:	1f 92       	push	r1
 4d0:	11 24       	eor	r1, r1
 4d2:	2f 92       	push	r2
 4d4:	3f 92       	push	r3
 4d6:	4f 92       	push	r4
 4d8:	5f 92       	push	r5
 4da:	6f 92       	push	r6
 4dc:	7f 92       	push	r7
 4de:	8f 92       	push	r8
 4e0:	9f 92       	push	r9
 4e2:	af 92       	push	r10
 4e4:	bf 92       	push	r11
 4e6:	cf 92       	push	r12
 4e8:	df 92       	push	r13
 4ea:	ef 92       	push	r14
 4ec:	ff 92       	push	r15
 4ee:	0f 93       	push	r16
 4f0:	1f 93       	push	r17
 4f2:	2f 93       	push	r18
 4f4:	3f 93       	push	r19
 4f6:	4f 93       	push	r20
 4f8:	5f 93       	push	r21
 4fa:	6f 93       	push	r22
 4fc:	7f 93       	push	r23
 4fe:	8f 93       	push	r24
 500:	9f 93       	push	r25
 502:	af 93       	push	r26
 504:	bf 93       	push	r27
 506:	cf 93       	push	r28
 508:	df 93       	push	r29
 50a:	ef 93       	push	r30
 50c:	ff 93       	push	r31
 50e:	a0 91 b5 23 	lds	r26, 0x23B5
 512:	b0 91 b6 23 	lds	r27, 0x23B6
 516:	0d b6       	in	r0, 0x3d	; 61
 518:	0d 92       	st	X+, r0
 51a:	0e b6       	in	r0, 0x3e	; 62
 51c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 51e:	0e 94 40 06 	call	0xc80	; 0xc80 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 522:	a0 91 b5 23 	lds	r26, 0x23B5
 526:	b0 91 b6 23 	lds	r27, 0x23B6
 52a:	cd 91       	ld	r28, X+
 52c:	cd bf       	out	0x3d, r28	; 61
 52e:	dd 91       	ld	r29, X+
 530:	de bf       	out	0x3e, r29	; 62
 532:	ff 91       	pop	r31
 534:	ef 91       	pop	r30
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	bf 91       	pop	r27
 53c:	af 91       	pop	r26
 53e:	9f 91       	pop	r25
 540:	8f 91       	pop	r24
 542:	7f 91       	pop	r23
 544:	6f 91       	pop	r22
 546:	5f 91       	pop	r21
 548:	4f 91       	pop	r20
 54a:	3f 91       	pop	r19
 54c:	2f 91       	pop	r18
 54e:	1f 91       	pop	r17
 550:	0f 91       	pop	r16
 552:	ff 90       	pop	r15
 554:	ef 90       	pop	r14
 556:	df 90       	pop	r13
 558:	cf 90       	pop	r12
 55a:	bf 90       	pop	r11
 55c:	af 90       	pop	r10
 55e:	9f 90       	pop	r9
 560:	8f 90       	pop	r8
 562:	7f 90       	pop	r7
 564:	6f 90       	pop	r6
 566:	5f 90       	pop	r5
 568:	4f 90       	pop	r4
 56a:	3f 90       	pop	r3
 56c:	2f 90       	pop	r2
 56e:	1f 90       	pop	r1
 570:	0f 90       	pop	r0
 572:	0f be       	out	0x3f, r0	; 63
 574:	0f 90       	pop	r0

	asm volatile ( "ret" );
 576:	08 95       	ret

00000578 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 578:	0f 92       	push	r0
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	f8 94       	cli
 57e:	0f 92       	push	r0
 580:	1f 92       	push	r1
 582:	11 24       	eor	r1, r1
 584:	2f 92       	push	r2
 586:	3f 92       	push	r3
 588:	4f 92       	push	r4
 58a:	5f 92       	push	r5
 58c:	6f 92       	push	r6
 58e:	7f 92       	push	r7
 590:	8f 92       	push	r8
 592:	9f 92       	push	r9
 594:	af 92       	push	r10
 596:	bf 92       	push	r11
 598:	cf 92       	push	r12
 59a:	df 92       	push	r13
 59c:	ef 92       	push	r14
 59e:	ff 92       	push	r15
 5a0:	0f 93       	push	r16
 5a2:	1f 93       	push	r17
 5a4:	2f 93       	push	r18
 5a6:	3f 93       	push	r19
 5a8:	4f 93       	push	r20
 5aa:	5f 93       	push	r21
 5ac:	6f 93       	push	r22
 5ae:	7f 93       	push	r23
 5b0:	8f 93       	push	r24
 5b2:	9f 93       	push	r25
 5b4:	af 93       	push	r26
 5b6:	bf 93       	push	r27
 5b8:	cf 93       	push	r28
 5ba:	df 93       	push	r29
 5bc:	ef 93       	push	r30
 5be:	ff 93       	push	r31
 5c0:	a0 91 b5 23 	lds	r26, 0x23B5
 5c4:	b0 91 b6 23 	lds	r27, 0x23B6
 5c8:	0d b6       	in	r0, 0x3d	; 61
 5ca:	0d 92       	st	X+, r0
 5cc:	0e b6       	in	r0, 0x3e	; 62
 5ce:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 5d0:	0e 94 f5 04 	call	0x9ea	; 0x9ea <xTaskIncrementTick>
 5d4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 5d6:	0e 94 40 06 	call	0xc80	; 0xc80 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 5da:	a0 91 b5 23 	lds	r26, 0x23B5
 5de:	b0 91 b6 23 	lds	r27, 0x23B6
 5e2:	cd 91       	ld	r28, X+
 5e4:	cd bf       	out	0x3d, r28	; 61
 5e6:	dd 91       	ld	r29, X+
 5e8:	de bf       	out	0x3e, r29	; 62
 5ea:	ff 91       	pop	r31
 5ec:	ef 91       	pop	r30
 5ee:	df 91       	pop	r29
 5f0:	cf 91       	pop	r28
 5f2:	bf 91       	pop	r27
 5f4:	af 91       	pop	r26
 5f6:	9f 91       	pop	r25
 5f8:	8f 91       	pop	r24
 5fa:	7f 91       	pop	r23
 5fc:	6f 91       	pop	r22
 5fe:	5f 91       	pop	r21
 600:	4f 91       	pop	r20
 602:	3f 91       	pop	r19
 604:	2f 91       	pop	r18
 606:	1f 91       	pop	r17
 608:	0f 91       	pop	r16
 60a:	ff 90       	pop	r15
 60c:	ef 90       	pop	r14
 60e:	df 90       	pop	r13
 610:	cf 90       	pop	r12
 612:	bf 90       	pop	r11
 614:	af 90       	pop	r10
 616:	9f 90       	pop	r9
 618:	8f 90       	pop	r8
 61a:	7f 90       	pop	r7
 61c:	6f 90       	pop	r6
 61e:	5f 90       	pop	r5
 620:	4f 90       	pop	r4
 622:	3f 90       	pop	r3
 624:	2f 90       	pop	r2
 626:	1f 90       	pop	r1
 628:	0f 90       	pop	r0
 62a:	0f be       	out	0x3f, r0	; 63
 62c:	0f 90       	pop	r0

	asm volatile ( "ret" );
 62e:	08 95       	ret

00000630 <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
 630:	0e 94 bc 02 	call	0x578	; 0x578 <vPortYieldFromTick>
		asm volatile ( "reti" );
 634:	18 95       	reti

00000636 <TC0_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
 636:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
 638:	90 81       	ld	r25, Z
 63a:	90 7f       	andi	r25, 0xF0	; 240
 63c:	69 2b       	or	r22, r25
 63e:	60 83       	st	Z, r22
 640:	08 95       	ret

00000642 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
 642:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
 644:	96 81       	ldd	r25, Z+6	; 0x06
 646:	9c 7f       	andi	r25, 0xFC	; 252
 648:	69 2b       	or	r22, r25
 64a:	66 83       	std	Z+6, r22	; 0x06
 64c:	08 95       	ret

0000064e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 64e:	cf 93       	push	r28
 650:	df 93       	push	r29
 652:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 654:	0e 94 ef 04 	call	0x9de	; 0x9de <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 658:	80 91 0e 20 	lds	r24, 0x200E
 65c:	90 91 0f 20 	lds	r25, 0x200F
 660:	89 2b       	or	r24, r25
 662:	31 f4       	brne	.+12     	; 0x670 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 664:	83 e1       	ldi	r24, 0x13	; 19
 666:	90 e2       	ldi	r25, 0x20	; 32
 668:	80 93 0e 20 	sts	0x200E, r24
 66c:	90 93 0f 20 	sts	0x200F, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 670:	20 91 10 20 	lds	r18, 0x2010
 674:	30 91 11 20 	lds	r19, 0x2011
 678:	ce 01       	movw	r24, r28
 67a:	82 0f       	add	r24, r18
 67c:	93 1f       	adc	r25, r19
 67e:	81 35       	cpi	r24, 0x51	; 81
 680:	43 e0       	ldi	r20, 0x03	; 3
 682:	94 07       	cpc	r25, r20
 684:	70 f4       	brcc	.+28     	; 0x6a2 <pvPortMalloc+0x54>
 686:	28 17       	cp	r18, r24
 688:	39 07       	cpc	r19, r25
 68a:	70 f4       	brcc	.+28     	; 0x6a8 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 68c:	c0 91 0e 20 	lds	r28, 0x200E
 690:	d0 91 0f 20 	lds	r29, 0x200F
 694:	c2 0f       	add	r28, r18
 696:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 698:	80 93 10 20 	sts	0x2010, r24
 69c:	90 93 11 20 	sts	0x2011, r25
 6a0:	05 c0       	rjmp	.+10     	; 0x6ac <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 6a2:	c0 e0       	ldi	r28, 0x00	; 0
 6a4:	d0 e0       	ldi	r29, 0x00	; 0
 6a6:	02 c0       	rjmp	.+4      	; 0x6ac <pvPortMalloc+0x5e>
 6a8:	c0 e0       	ldi	r28, 0x00	; 0
 6aa:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 6ac:	0e 94 ad 05 	call	0xb5a	; 0xb5a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 6b0:	ce 01       	movw	r24, r28
 6b2:	df 91       	pop	r29
 6b4:	cf 91       	pop	r28
 6b6:	08 95       	ret

000006b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 6b8:	08 95       	ret

000006ba <prvIdleTask>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 6ba:	ff cf       	rjmp	.-2      	; 0x6ba <prvIdleTask>

000006bc <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 6bc:	e0 91 7d 23 	lds	r30, 0x237D
 6c0:	f0 91 7e 23 	lds	r31, 0x237E
 6c4:	80 81       	ld	r24, Z
 6c6:	81 11       	cpse	r24, r1
 6c8:	07 c0       	rjmp	.+14     	; 0x6d8 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 6ca:	8f ef       	ldi	r24, 0xFF	; 255
 6cc:	9f ef       	ldi	r25, 0xFF	; 255
 6ce:	80 93 67 23 	sts	0x2367, r24
 6d2:	90 93 68 23 	sts	0x2368, r25
 6d6:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 6d8:	e0 91 7d 23 	lds	r30, 0x237D
 6dc:	f0 91 7e 23 	lds	r31, 0x237E
 6e0:	05 80       	ldd	r0, Z+5	; 0x05
 6e2:	f6 81       	ldd	r31, Z+6	; 0x06
 6e4:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 6e6:	06 80       	ldd	r0, Z+6	; 0x06
 6e8:	f7 81       	ldd	r31, Z+7	; 0x07
 6ea:	e0 2d       	mov	r30, r0
 6ec:	82 81       	ldd	r24, Z+2	; 0x02
 6ee:	93 81       	ldd	r25, Z+3	; 0x03
 6f0:	80 93 67 23 	sts	0x2367, r24
 6f4:	90 93 68 23 	sts	0x2368, r25
 6f8:	08 95       	ret

000006fa <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 6fa:	0f 93       	push	r16
 6fc:	1f 93       	push	r17
 6fe:	cf 93       	push	r28
 700:	df 93       	push	r29
 702:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 704:	00 91 6f 23 	lds	r16, 0x236F
 708:	10 91 70 23 	lds	r17, 0x2370
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 70c:	80 91 b5 23 	lds	r24, 0x23B5
 710:	90 91 b6 23 	lds	r25, 0x23B6
 714:	02 96       	adiw	r24, 0x02	; 2
 716:	0e 94 8d 01 	call	0x31a	; 0x31a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
 71a:	c0 0f       	add	r28, r16
 71c:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 71e:	e0 91 b5 23 	lds	r30, 0x23B5
 722:	f0 91 b6 23 	lds	r31, 0x23B6
 726:	c2 83       	std	Z+2, r28	; 0x02
 728:	d3 83       	std	Z+3, r29	; 0x03

		if( xTimeToWake < xConstTickCount )
 72a:	c0 17       	cp	r28, r16
 72c:	d1 07       	cpc	r29, r17
 72e:	68 f4       	brcc	.+26     	; 0x74a <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 730:	60 91 b5 23 	lds	r22, 0x23B5
 734:	70 91 b6 23 	lds	r23, 0x23B6
 738:	80 91 7b 23 	lds	r24, 0x237B
 73c:	90 91 7c 23 	lds	r25, 0x237C
 740:	6e 5f       	subi	r22, 0xFE	; 254
 742:	7f 4f       	sbci	r23, 0xFF	; 255
 744:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <vListInsert>
 748:	17 c0       	rjmp	.+46     	; 0x778 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 74a:	60 91 b5 23 	lds	r22, 0x23B5
 74e:	70 91 b6 23 	lds	r23, 0x23B6
 752:	80 91 7d 23 	lds	r24, 0x237D
 756:	90 91 7e 23 	lds	r25, 0x237E
 75a:	6e 5f       	subi	r22, 0xFE	; 254
 75c:	7f 4f       	sbci	r23, 0xFF	; 255
 75e:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
 762:	80 91 67 23 	lds	r24, 0x2367
 766:	90 91 68 23 	lds	r25, 0x2368
 76a:	c8 17       	cp	r28, r24
 76c:	d9 07       	cpc	r29, r25
 76e:	20 f4       	brcc	.+8      	; 0x778 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
 770:	c0 93 67 23 	sts	0x2367, r28
 774:	d0 93 68 23 	sts	0x2368, r29

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 778:	df 91       	pop	r29
 77a:	cf 91       	pop	r28
 77c:	1f 91       	pop	r17
 77e:	0f 91       	pop	r16
 780:	08 95       	ret

00000782 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 782:	4f 92       	push	r4
 784:	5f 92       	push	r5
 786:	6f 92       	push	r6
 788:	7f 92       	push	r7
 78a:	8f 92       	push	r8
 78c:	9f 92       	push	r9
 78e:	af 92       	push	r10
 790:	bf 92       	push	r11
 792:	cf 92       	push	r12
 794:	df 92       	push	r13
 796:	ef 92       	push	r14
 798:	ff 92       	push	r15
 79a:	0f 93       	push	r16
 79c:	cf 93       	push	r28
 79e:	df 93       	push	r29
 7a0:	4c 01       	movw	r8, r24
 7a2:	6b 01       	movw	r12, r22
 7a4:	5a 01       	movw	r10, r20
 7a6:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 7a8:	ca 01       	movw	r24, r20
 7aa:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
 7ae:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
 7b0:	89 2b       	or	r24, r25
 7b2:	09 f4       	brne	.+2      	; 0x7b6 <xTaskCreate+0x34>
 7b4:	d9 c0       	rjmp	.+434    	; 0x968 <xTaskCreate+0x1e6>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 7b6:	86 e2       	ldi	r24, 0x26	; 38
 7b8:	90 e0       	ldi	r25, 0x00	; 0
 7ba:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
 7be:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
 7c0:	89 2b       	or	r24, r25
 7c2:	71 f0       	breq	.+28     	; 0x7e0 <xTaskCreate+0x5e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 7c4:	6f 8a       	std	Y+23, r6	; 0x17
 7c6:	78 8e       	std	Y+24, r7	; 0x18
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 7c8:	81 e0       	ldi	r24, 0x01	; 1
 7ca:	a8 1a       	sub	r10, r24
 7cc:	b1 08       	sbc	r11, r1
 7ce:	6a 0c       	add	r6, r10
 7d0:	7b 1c       	adc	r7, r11
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 7d2:	d6 01       	movw	r26, r12
 7d4:	8c 91       	ld	r24, X
 7d6:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 7d8:	8c 91       	ld	r24, X
 7da:	81 11       	cpse	r24, r1
 7dc:	05 c0       	rjmp	.+10     	; 0x7e8 <xTaskCreate+0x66>
 7de:	18 c0       	rjmp	.+48     	; 0x810 <xTaskCreate+0x8e>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 7e0:	c3 01       	movw	r24, r6
 7e2:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <vPortFree>
 7e6:	c0 c0       	rjmp	.+384    	; 0x968 <xTaskCreate+0x1e6>
 7e8:	ae 01       	movw	r20, r28
 7ea:	46 5e       	subi	r20, 0xE6	; 230
 7ec:	5f 4f       	sbci	r21, 0xFF	; 255
 7ee:	f6 01       	movw	r30, r12
 7f0:	31 96       	adiw	r30, 0x01	; 1
 7f2:	b8 e0       	ldi	r27, 0x08	; 8
 7f4:	cb 0e       	add	r12, r27
 7f6:	d1 1c       	adc	r13, r1
 7f8:	cf 01       	movw	r24, r30
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 7fa:	21 91       	ld	r18, Z+
 7fc:	da 01       	movw	r26, r20
 7fe:	2d 93       	st	X+, r18
 800:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 802:	dc 01       	movw	r26, r24
 804:	8c 91       	ld	r24, X
 806:	88 23       	and	r24, r24
 808:	19 f0       	breq	.+6      	; 0x810 <xTaskCreate+0x8e>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80a:	ec 15       	cp	r30, r12
 80c:	fd 05       	cpc	r31, r13
 80e:	a1 f7       	brne	.-24     	; 0x7f8 <xTaskCreate+0x76>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 810:	18 a2       	std	Y+32, r1	; 0x20
 812:	04 30       	cpi	r16, 0x04	; 4
 814:	08 f0       	brcs	.+2      	; 0x818 <xTaskCreate+0x96>
 816:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 818:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 81a:	6e 01       	movw	r12, r28
 81c:	b2 e0       	ldi	r27, 0x02	; 2
 81e:	cb 0e       	add	r12, r27
 820:	d1 1c       	adc	r13, r1
 822:	c6 01       	movw	r24, r12
 824:	0e 94 37 01 	call	0x26e	; 0x26e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 828:	ce 01       	movw	r24, r28
 82a:	0c 96       	adiw	r24, 0x0c	; 12
 82c:	0e 94 37 01 	call	0x26e	; 0x26e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 830:	c8 87       	std	Y+8, r28	; 0x08
 832:	d9 87       	std	Y+9, r29	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 834:	84 e0       	ldi	r24, 0x04	; 4
 836:	90 e0       	ldi	r25, 0x00	; 0
 838:	80 1b       	sub	r24, r16
 83a:	91 09       	sbc	r25, r1
 83c:	8c 87       	std	Y+12, r24	; 0x0c
 83e:	9d 87       	std	Y+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 840:	ca 8b       	std	Y+18, r28	; 0x12
 842:	db 8b       	std	Y+19, r29	; 0x13
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 844:	19 a2       	std	Y+33, r1	; 0x21
 846:	1a a2       	std	Y+34, r1	; 0x22
 848:	1b a2       	std	Y+35, r1	; 0x23
 84a:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 84c:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 84e:	a2 01       	movw	r20, r4
 850:	b4 01       	movw	r22, r8
 852:	c3 01       	movw	r24, r6
 854:	0e 94 b3 01 	call	0x366	; 0x366 <pxPortInitialiseStack>
 858:	88 83       	st	Y, r24
 85a:	99 83       	std	Y+1, r25	; 0x01
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 85c:	e1 14       	cp	r14, r1
 85e:	f1 04       	cpc	r15, r1
 860:	19 f0       	breq	.+6      	; 0x868 <xTaskCreate+0xe6>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 862:	f7 01       	movw	r30, r14
 864:	c0 83       	st	Z, r28
 866:	d1 83       	std	Z+1, r29	; 0x01

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 868:	0f b6       	in	r0, 0x3f	; 63
 86a:	f8 94       	cli
 86c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
 86e:	80 91 71 23 	lds	r24, 0x2371
 872:	8f 5f       	subi	r24, 0xFF	; 255
 874:	80 93 71 23 	sts	0x2371, r24
		if( pxCurrentTCB == NULL )
 878:	80 91 b5 23 	lds	r24, 0x23B5
 87c:	90 91 b6 23 	lds	r25, 0x23B6
 880:	89 2b       	or	r24, r25
 882:	89 f5       	brne	.+98     	; 0x8e6 <xTaskCreate+0x164>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 884:	c0 93 b5 23 	sts	0x23B5, r28
 888:	d0 93 b6 23 	sts	0x23B6, r29

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 88c:	80 91 71 23 	lds	r24, 0x2371
 890:	81 30       	cpi	r24, 0x01	; 1
 892:	c9 f5       	brne	.+114    	; 0x906 <xTaskCreate+0x184>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 894:	81 e9       	ldi	r24, 0x91	; 145
 896:	93 e2       	ldi	r25, 0x23	; 35
 898:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
 89c:	8a e9       	ldi	r24, 0x9A	; 154
 89e:	93 e2       	ldi	r25, 0x23	; 35
 8a0:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
 8a4:	83 ea       	ldi	r24, 0xA3	; 163
 8a6:	93 e2       	ldi	r25, 0x23	; 35
 8a8:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
 8ac:	8c ea       	ldi	r24, 0xAC	; 172
 8ae:	93 e2       	ldi	r25, 0x23	; 35
 8b0:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 8b4:	88 e8       	ldi	r24, 0x88	; 136
 8b6:	93 e2       	ldi	r25, 0x23	; 35
 8b8:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8bc:	8f e7       	ldi	r24, 0x7F	; 127
 8be:	93 e2       	ldi	r25, 0x23	; 35
 8c0:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8c4:	82 e7       	ldi	r24, 0x72	; 114
 8c6:	93 e2       	ldi	r25, 0x23	; 35
 8c8:	0e 94 29 01 	call	0x252	; 0x252 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8cc:	88 e8       	ldi	r24, 0x88	; 136
 8ce:	93 e2       	ldi	r25, 0x23	; 35
 8d0:	80 93 7d 23 	sts	0x237D, r24
 8d4:	90 93 7e 23 	sts	0x237E, r25
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8d8:	8f e7       	ldi	r24, 0x7F	; 127
 8da:	93 e2       	ldi	r25, 0x23	; 35
 8dc:	80 93 7b 23 	sts	0x237B, r24
 8e0:	90 93 7c 23 	sts	0x237C, r25
 8e4:	10 c0       	rjmp	.+32     	; 0x906 <xTaskCreate+0x184>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8e6:	80 91 6d 23 	lds	r24, 0x236D
 8ea:	81 11       	cpse	r24, r1
 8ec:	0c c0       	rjmp	.+24     	; 0x906 <xTaskCreate+0x184>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8ee:	e0 91 b5 23 	lds	r30, 0x23B5
 8f2:	f0 91 b6 23 	lds	r31, 0x23B6
 8f6:	96 89       	ldd	r25, Z+22	; 0x16
 8f8:	8e 89       	ldd	r24, Y+22	; 0x16
 8fa:	89 17       	cp	r24, r25
 8fc:	20 f0       	brcs	.+8      	; 0x906 <xTaskCreate+0x184>
				{
					pxCurrentTCB = pxNewTCB;
 8fe:	c0 93 b5 23 	sts	0x23B5, r28
 902:	d0 93 b6 23 	sts	0x23B6, r29
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 906:	80 91 69 23 	lds	r24, 0x2369
 90a:	8f 5f       	subi	r24, 0xFF	; 255
 90c:	80 93 69 23 	sts	0x2369, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 910:	8e 89       	ldd	r24, Y+22	; 0x16
 912:	90 91 6e 23 	lds	r25, 0x236E
 916:	98 17       	cp	r25, r24
 918:	10 f4       	brcc	.+4      	; 0x91e <xTaskCreate+0x19c>
 91a:	80 93 6e 23 	sts	0x236E, r24
 91e:	90 e0       	ldi	r25, 0x00	; 0
 920:	9c 01       	movw	r18, r24
 922:	22 0f       	add	r18, r18
 924:	33 1f       	adc	r19, r19
 926:	22 0f       	add	r18, r18
 928:	33 1f       	adc	r19, r19
 92a:	22 0f       	add	r18, r18
 92c:	33 1f       	adc	r19, r19
 92e:	82 0f       	add	r24, r18
 930:	93 1f       	adc	r25, r19
 932:	b6 01       	movw	r22, r12
 934:	8f 56       	subi	r24, 0x6F	; 111
 936:	9c 4d       	sbci	r25, 0xDC	; 220
 938:	0e 94 3b 01 	call	0x276	; 0x276 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 93c:	0f 90       	pop	r0
 93e:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
 940:	80 91 6d 23 	lds	r24, 0x236D
 944:	88 23       	and	r24, r24
 946:	61 f0       	breq	.+24     	; 0x960 <xTaskCreate+0x1de>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 948:	e0 91 b5 23 	lds	r30, 0x23B5
 94c:	f0 91 b6 23 	lds	r31, 0x23B6
 950:	96 89       	ldd	r25, Z+22	; 0x16
 952:	8e 89       	ldd	r24, Y+22	; 0x16
 954:	98 17       	cp	r25, r24
 956:	30 f4       	brcc	.+12     	; 0x964 <xTaskCreate+0x1e2>
		{
			taskYIELD_IF_USING_PREEMPTION();
 958:	0e 94 63 02 	call	0x4c6	; 0x4c6 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
 95c:	81 e0       	ldi	r24, 0x01	; 1
 95e:	05 c0       	rjmp	.+10     	; 0x96a <xTaskCreate+0x1e8>
 960:	81 e0       	ldi	r24, 0x01	; 1
 962:	03 c0       	rjmp	.+6      	; 0x96a <xTaskCreate+0x1e8>
 964:	81 e0       	ldi	r24, 0x01	; 1
 966:	01 c0       	rjmp	.+2      	; 0x96a <xTaskCreate+0x1e8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 968:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
 96a:	df 91       	pop	r29
 96c:	cf 91       	pop	r28
 96e:	0f 91       	pop	r16
 970:	ff 90       	pop	r15
 972:	ef 90       	pop	r14
 974:	df 90       	pop	r13
 976:	cf 90       	pop	r12
 978:	bf 90       	pop	r11
 97a:	af 90       	pop	r10
 97c:	9f 90       	pop	r9
 97e:	8f 90       	pop	r8
 980:	7f 90       	pop	r7
 982:	6f 90       	pop	r6
 984:	5f 90       	pop	r5
 986:	4f 90       	pop	r4
 988:	08 95       	ret

0000098a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 98a:	ef 92       	push	r14
 98c:	ff 92       	push	r15
 98e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 990:	0f 2e       	mov	r0, r31
 992:	f5 e6       	ldi	r31, 0x65	; 101
 994:	ef 2e       	mov	r14, r31
 996:	f3 e2       	ldi	r31, 0x23	; 35
 998:	ff 2e       	mov	r15, r31
 99a:	f0 2d       	mov	r31, r0
 99c:	00 e0       	ldi	r16, 0x00	; 0
 99e:	20 e0       	ldi	r18, 0x00	; 0
 9a0:	30 e0       	ldi	r19, 0x00	; 0
 9a2:	45 e5       	ldi	r20, 0x55	; 85
 9a4:	50 e0       	ldi	r21, 0x00	; 0
 9a6:	60 e0       	ldi	r22, 0x00	; 0
 9a8:	70 e2       	ldi	r23, 0x20	; 32
 9aa:	8d e5       	ldi	r24, 0x5D	; 93
 9ac:	93 e0       	ldi	r25, 0x03	; 3
 9ae:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 9b2:	81 30       	cpi	r24, 0x01	; 1
 9b4:	81 f4       	brne	.+32     	; 0x9d6 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 9b6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 9b8:	8f ef       	ldi	r24, 0xFF	; 255
 9ba:	9f ef       	ldi	r25, 0xFF	; 255
 9bc:	80 93 67 23 	sts	0x2367, r24
 9c0:	90 93 68 23 	sts	0x2368, r25
		xSchedulerRunning = pdTRUE;
 9c4:	81 e0       	ldi	r24, 0x01	; 1
 9c6:	80 93 6d 23 	sts	0x236D, r24
		xTickCount = ( TickType_t ) 0U;
 9ca:	10 92 6f 23 	sts	0x236F, r1
 9ce:	10 92 70 23 	sts	0x2370, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 9d2:	0e 94 21 02 	call	0x442	; 0x442 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 9d6:	0f 91       	pop	r16
 9d8:	ff 90       	pop	r15
 9da:	ef 90       	pop	r14
 9dc:	08 95       	ret

000009de <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 9de:	80 91 64 23 	lds	r24, 0x2364
 9e2:	8f 5f       	subi	r24, 0xFF	; 255
 9e4:	80 93 64 23 	sts	0x2364, r24
 9e8:	08 95       	ret

000009ea <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 9ea:	df 92       	push	r13
 9ec:	ef 92       	push	r14
 9ee:	ff 92       	push	r15
 9f0:	0f 93       	push	r16
 9f2:	1f 93       	push	r17
 9f4:	cf 93       	push	r28
 9f6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 9f8:	80 91 64 23 	lds	r24, 0x2364
 9fc:	81 11       	cpse	r24, r1
 9fe:	98 c0       	rjmp	.+304    	; 0xb30 <xTaskIncrementTick+0x146>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 a00:	e0 90 6f 23 	lds	r14, 0x236F
 a04:	f0 90 70 23 	lds	r15, 0x2370
 a08:	8f ef       	ldi	r24, 0xFF	; 255
 a0a:	e8 1a       	sub	r14, r24
 a0c:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 a0e:	e0 92 6f 23 	sts	0x236F, r14
 a12:	f0 92 70 23 	sts	0x2370, r15

		if( xConstTickCount == ( TickType_t ) 0U )
 a16:	e1 14       	cp	r14, r1
 a18:	f1 04       	cpc	r15, r1
 a1a:	b9 f4       	brne	.+46     	; 0xa4a <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 a1c:	80 91 7d 23 	lds	r24, 0x237D
 a20:	90 91 7e 23 	lds	r25, 0x237E
 a24:	20 91 7b 23 	lds	r18, 0x237B
 a28:	30 91 7c 23 	lds	r19, 0x237C
 a2c:	20 93 7d 23 	sts	0x237D, r18
 a30:	30 93 7e 23 	sts	0x237E, r19
 a34:	80 93 7b 23 	sts	0x237B, r24
 a38:	90 93 7c 23 	sts	0x237C, r25
 a3c:	80 91 6a 23 	lds	r24, 0x236A
 a40:	8f 5f       	subi	r24, 0xFF	; 255
 a42:	80 93 6a 23 	sts	0x236A, r24
 a46:	0e 94 5e 03 	call	0x6bc	; 0x6bc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 a4a:	80 91 67 23 	lds	r24, 0x2367
 a4e:	90 91 68 23 	lds	r25, 0x2368
 a52:	e8 16       	cp	r14, r24
 a54:	f9 06       	cpc	r15, r25
 a56:	10 f4       	brcc	.+4      	; 0xa5c <xTaskIncrementTick+0x72>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a58:	d1 2c       	mov	r13, r1
 a5a:	52 c0       	rjmp	.+164    	; 0xb00 <xTaskIncrementTick+0x116>
 a5c:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 a5e:	e0 91 7d 23 	lds	r30, 0x237D
 a62:	f0 91 7e 23 	lds	r31, 0x237E
 a66:	90 81       	ld	r25, Z
 a68:	91 11       	cpse	r25, r1
 a6a:	07 c0       	rjmp	.+14     	; 0xa7a <xTaskIncrementTick+0x90>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 a6c:	8f ef       	ldi	r24, 0xFF	; 255
 a6e:	9f ef       	ldi	r25, 0xFF	; 255
 a70:	80 93 67 23 	sts	0x2367, r24
 a74:	90 93 68 23 	sts	0x2368, r25
					break;
 a78:	43 c0       	rjmp	.+134    	; 0xb00 <xTaskIncrementTick+0x116>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 a7a:	e0 91 7d 23 	lds	r30, 0x237D
 a7e:	f0 91 7e 23 	lds	r31, 0x237E
 a82:	05 80       	ldd	r0, Z+5	; 0x05
 a84:	f6 81       	ldd	r31, Z+6	; 0x06
 a86:	e0 2d       	mov	r30, r0
 a88:	c6 81       	ldd	r28, Z+6	; 0x06
 a8a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 a8c:	2a 81       	ldd	r18, Y+2	; 0x02
 a8e:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
 a90:	e2 16       	cp	r14, r18
 a92:	f3 06       	cpc	r15, r19
 a94:	28 f4       	brcc	.+10     	; 0xaa0 <xTaskIncrementTick+0xb6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 a96:	20 93 67 23 	sts	0x2367, r18
 a9a:	30 93 68 23 	sts	0x2368, r19
						break;
 a9e:	30 c0       	rjmp	.+96     	; 0xb00 <xTaskIncrementTick+0x116>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 aa0:	8e 01       	movw	r16, r28
 aa2:	0e 5f       	subi	r16, 0xFE	; 254
 aa4:	1f 4f       	sbci	r17, 0xFF	; 255
 aa6:	c8 01       	movw	r24, r16
 aa8:	0e 94 8d 01 	call	0x31a	; 0x31a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 aac:	8c 89       	ldd	r24, Y+20	; 0x14
 aae:	9d 89       	ldd	r25, Y+21	; 0x15
 ab0:	89 2b       	or	r24, r25
 ab2:	21 f0       	breq	.+8      	; 0xabc <xTaskIncrementTick+0xd2>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 ab4:	ce 01       	movw	r24, r28
 ab6:	0c 96       	adiw	r24, 0x0c	; 12
 ab8:	0e 94 8d 01 	call	0x31a	; 0x31a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 abc:	2e 89       	ldd	r18, Y+22	; 0x16
 abe:	80 91 6e 23 	lds	r24, 0x236E
 ac2:	82 17       	cp	r24, r18
 ac4:	10 f4       	brcc	.+4      	; 0xaca <xTaskIncrementTick+0xe0>
 ac6:	20 93 6e 23 	sts	0x236E, r18
 aca:	30 e0       	ldi	r19, 0x00	; 0
 acc:	c9 01       	movw	r24, r18
 ace:	88 0f       	add	r24, r24
 ad0:	99 1f       	adc	r25, r25
 ad2:	88 0f       	add	r24, r24
 ad4:	99 1f       	adc	r25, r25
 ad6:	88 0f       	add	r24, r24
 ad8:	99 1f       	adc	r25, r25
 ada:	82 0f       	add	r24, r18
 adc:	93 1f       	adc	r25, r19
 ade:	b8 01       	movw	r22, r16
 ae0:	8f 56       	subi	r24, 0x6F	; 111
 ae2:	9c 4d       	sbci	r25, 0xDC	; 220
 ae4:	0e 94 3b 01 	call	0x276	; 0x276 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 ae8:	e0 91 b5 23 	lds	r30, 0x23B5
 aec:	f0 91 b6 23 	lds	r31, 0x23B6
 af0:	9e 89       	ldd	r25, Y+22	; 0x16
 af2:	86 89       	ldd	r24, Z+22	; 0x16
 af4:	98 17       	cp	r25, r24
 af6:	08 f4       	brcc	.+2      	; 0xafa <xTaskIncrementTick+0x110>
 af8:	b2 cf       	rjmp	.-156    	; 0xa5e <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
 afa:	dd 24       	eor	r13, r13
 afc:	d3 94       	inc	r13
 afe:	af cf       	rjmp	.-162    	; 0xa5e <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 b00:	e0 91 b5 23 	lds	r30, 0x23B5
 b04:	f0 91 b6 23 	lds	r31, 0x23B6
 b08:	86 89       	ldd	r24, Z+22	; 0x16
 b0a:	90 e0       	ldi	r25, 0x00	; 0
 b0c:	fc 01       	movw	r30, r24
 b0e:	ee 0f       	add	r30, r30
 b10:	ff 1f       	adc	r31, r31
 b12:	ee 0f       	add	r30, r30
 b14:	ff 1f       	adc	r31, r31
 b16:	ee 0f       	add	r30, r30
 b18:	ff 1f       	adc	r31, r31
 b1a:	8e 0f       	add	r24, r30
 b1c:	9f 1f       	adc	r25, r31
 b1e:	fc 01       	movw	r30, r24
 b20:	ef 56       	subi	r30, 0x6F	; 111
 b22:	fc 4d       	sbci	r31, 0xDC	; 220
 b24:	80 81       	ld	r24, Z
 b26:	82 30       	cpi	r24, 0x02	; 2
 b28:	48 f0       	brcs	.+18     	; 0xb3c <xTaskIncrementTick+0x152>
			{
				xSwitchRequired = pdTRUE;
 b2a:	dd 24       	eor	r13, r13
 b2c:	d3 94       	inc	r13
 b2e:	06 c0       	rjmp	.+12     	; 0xb3c <xTaskIncrementTick+0x152>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 b30:	80 91 6c 23 	lds	r24, 0x236C
 b34:	8f 5f       	subi	r24, 0xFF	; 255
 b36:	80 93 6c 23 	sts	0x236C, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 b3a:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 b3c:	80 91 6b 23 	lds	r24, 0x236B
 b40:	88 23       	and	r24, r24
 b42:	11 f0       	breq	.+4      	; 0xb48 <xTaskIncrementTick+0x15e>
		{
			xSwitchRequired = pdTRUE;
 b44:	dd 24       	eor	r13, r13
 b46:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 b48:	8d 2d       	mov	r24, r13
 b4a:	df 91       	pop	r29
 b4c:	cf 91       	pop	r28
 b4e:	1f 91       	pop	r17
 b50:	0f 91       	pop	r16
 b52:	ff 90       	pop	r15
 b54:	ef 90       	pop	r14
 b56:	df 90       	pop	r13
 b58:	08 95       	ret

00000b5a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 b5a:	df 92       	push	r13
 b5c:	ef 92       	push	r14
 b5e:	ff 92       	push	r15
 b60:	0f 93       	push	r16
 b62:	1f 93       	push	r17
 b64:	cf 93       	push	r28
 b66:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 b68:	0f b6       	in	r0, 0x3f	; 63
 b6a:	f8 94       	cli
 b6c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 b6e:	80 91 64 23 	lds	r24, 0x2364
 b72:	81 50       	subi	r24, 0x01	; 1
 b74:	80 93 64 23 	sts	0x2364, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 b78:	80 91 64 23 	lds	r24, 0x2364
 b7c:	81 11       	cpse	r24, r1
 b7e:	5f c0       	rjmp	.+190    	; 0xc3e <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 b80:	80 91 71 23 	lds	r24, 0x2371
 b84:	81 11       	cpse	r24, r1
 b86:	33 c0       	rjmp	.+102    	; 0xbee <xTaskResumeAll+0x94>
 b88:	5d c0       	rjmp	.+186    	; 0xc44 <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 b8a:	d7 01       	movw	r26, r14
 b8c:	15 96       	adiw	r26, 0x05	; 5
 b8e:	ed 91       	ld	r30, X+
 b90:	fc 91       	ld	r31, X
 b92:	16 97       	sbiw	r26, 0x06	; 6
 b94:	c6 81       	ldd	r28, Z+6	; 0x06
 b96:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 b98:	ce 01       	movw	r24, r28
 b9a:	0c 96       	adiw	r24, 0x0c	; 12
 b9c:	0e 94 8d 01 	call	0x31a	; 0x31a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 ba0:	8e 01       	movw	r16, r28
 ba2:	0e 5f       	subi	r16, 0xFE	; 254
 ba4:	1f 4f       	sbci	r17, 0xFF	; 255
 ba6:	c8 01       	movw	r24, r16
 ba8:	0e 94 8d 01 	call	0x31a	; 0x31a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 bac:	2e 89       	ldd	r18, Y+22	; 0x16
 bae:	80 91 6e 23 	lds	r24, 0x236E
 bb2:	82 17       	cp	r24, r18
 bb4:	10 f4       	brcc	.+4      	; 0xbba <xTaskResumeAll+0x60>
 bb6:	20 93 6e 23 	sts	0x236E, r18
 bba:	30 e0       	ldi	r19, 0x00	; 0
 bbc:	c9 01       	movw	r24, r18
 bbe:	88 0f       	add	r24, r24
 bc0:	99 1f       	adc	r25, r25
 bc2:	88 0f       	add	r24, r24
 bc4:	99 1f       	adc	r25, r25
 bc6:	88 0f       	add	r24, r24
 bc8:	99 1f       	adc	r25, r25
 bca:	82 0f       	add	r24, r18
 bcc:	93 1f       	adc	r25, r19
 bce:	b8 01       	movw	r22, r16
 bd0:	8f 56       	subi	r24, 0x6F	; 111
 bd2:	9c 4d       	sbci	r25, 0xDC	; 220
 bd4:	0e 94 3b 01 	call	0x276	; 0x276 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 bd8:	e0 91 b5 23 	lds	r30, 0x23B5
 bdc:	f0 91 b6 23 	lds	r31, 0x23B6
 be0:	9e 89       	ldd	r25, Y+22	; 0x16
 be2:	86 89       	ldd	r24, Z+22	; 0x16
 be4:	98 17       	cp	r25, r24
 be6:	68 f0       	brcs	.+26     	; 0xc02 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
 be8:	d0 92 6b 23 	sts	0x236B, r13
 bec:	0a c0       	rjmp	.+20     	; 0xc02 <xTaskResumeAll+0xa8>
 bee:	c0 e0       	ldi	r28, 0x00	; 0
 bf0:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 bf2:	0f 2e       	mov	r0, r31
 bf4:	f2 e7       	ldi	r31, 0x72	; 114
 bf6:	ef 2e       	mov	r14, r31
 bf8:	f3 e2       	ldi	r31, 0x23	; 35
 bfa:	ff 2e       	mov	r15, r31
 bfc:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 bfe:	dd 24       	eor	r13, r13
 c00:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c02:	f7 01       	movw	r30, r14
 c04:	80 81       	ld	r24, Z
 c06:	81 11       	cpse	r24, r1
 c08:	c0 cf       	rjmp	.-128    	; 0xb8a <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 c0a:	cd 2b       	or	r28, r29
 c0c:	11 f0       	breq	.+4      	; 0xc12 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 c0e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 c12:	c0 91 6c 23 	lds	r28, 0x236C

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 c16:	cc 23       	and	r28, r28
 c18:	51 f0       	breq	.+20     	; 0xc2e <xTaskResumeAll+0xd4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 c1a:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 c1c:	0e 94 f5 04 	call	0x9ea	; 0x9ea <xTaskIncrementTick>
 c20:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
 c22:	d0 93 6b 23 	sts	0x236B, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 c26:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 c28:	c9 f7       	brne	.-14     	; 0xc1c <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
 c2a:	10 92 6c 23 	sts	0x236C, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 c2e:	80 91 6b 23 	lds	r24, 0x236B
 c32:	88 23       	and	r24, r24
 c34:	31 f0       	breq	.+12     	; 0xc42 <xTaskResumeAll+0xe8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 c36:	0e 94 63 02 	call	0x4c6	; 0x4c6 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 c3a:	81 e0       	ldi	r24, 0x01	; 1
 c3c:	03 c0       	rjmp	.+6      	; 0xc44 <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 c3e:	80 e0       	ldi	r24, 0x00	; 0
 c40:	01 c0       	rjmp	.+2      	; 0xc44 <xTaskResumeAll+0xea>
 c42:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 c44:	0f 90       	pop	r0
 c46:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 c48:	df 91       	pop	r29
 c4a:	cf 91       	pop	r28
 c4c:	1f 91       	pop	r17
 c4e:	0f 91       	pop	r16
 c50:	ff 90       	pop	r15
 c52:	ef 90       	pop	r14
 c54:	df 90       	pop	r13
 c56:	08 95       	ret

00000c58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 c58:	cf 93       	push	r28
 c5a:	df 93       	push	r29
 c5c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 c5e:	89 2b       	or	r24, r25
 c60:	51 f0       	breq	.+20     	; 0xc76 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c62:	0e 94 ef 04 	call	0x9de	; 0x9de <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 c66:	60 e0       	ldi	r22, 0x00	; 0
 c68:	ce 01       	movw	r24, r28
 c6a:	0e 94 7d 03 	call	0x6fa	; 0x6fa <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 c6e:	0e 94 ad 05 	call	0xb5a	; 0xb5a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c72:	81 11       	cpse	r24, r1
 c74:	02 c0       	rjmp	.+4      	; 0xc7a <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 c76:	0e 94 63 02 	call	0x4c6	; 0x4c6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 c7a:	df 91       	pop	r29
 c7c:	cf 91       	pop	r28
 c7e:	08 95       	ret

00000c80 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c80:	80 91 64 23 	lds	r24, 0x2364
 c84:	88 23       	and	r24, r24
 c86:	21 f0       	breq	.+8      	; 0xc90 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c88:	81 e0       	ldi	r24, 0x01	; 1
 c8a:	80 93 6b 23 	sts	0x236B, r24
 c8e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 c90:	10 92 6b 23 	sts	0x236B, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 c94:	20 91 6e 23 	lds	r18, 0x236E
 c98:	82 2f       	mov	r24, r18
 c9a:	90 e0       	ldi	r25, 0x00	; 0
 c9c:	fc 01       	movw	r30, r24
 c9e:	ee 0f       	add	r30, r30
 ca0:	ff 1f       	adc	r31, r31
 ca2:	ee 0f       	add	r30, r30
 ca4:	ff 1f       	adc	r31, r31
 ca6:	ee 0f       	add	r30, r30
 ca8:	ff 1f       	adc	r31, r31
 caa:	e8 0f       	add	r30, r24
 cac:	f9 1f       	adc	r31, r25
 cae:	ef 56       	subi	r30, 0x6F	; 111
 cb0:	fc 4d       	sbci	r31, 0xDC	; 220
 cb2:	30 81       	ld	r19, Z
 cb4:	31 11       	cpse	r19, r1
 cb6:	11 c0       	rjmp	.+34     	; 0xcda <vTaskSwitchContext+0x5a>
 cb8:	21 50       	subi	r18, 0x01	; 1
 cba:	82 2f       	mov	r24, r18
 cbc:	90 e0       	ldi	r25, 0x00	; 0
 cbe:	fc 01       	movw	r30, r24
 cc0:	ee 0f       	add	r30, r30
 cc2:	ff 1f       	adc	r31, r31
 cc4:	ee 0f       	add	r30, r30
 cc6:	ff 1f       	adc	r31, r31
 cc8:	ee 0f       	add	r30, r30
 cca:	ff 1f       	adc	r31, r31
 ccc:	e8 0f       	add	r30, r24
 cce:	f9 1f       	adc	r31, r25
 cd0:	ef 56       	subi	r30, 0x6F	; 111
 cd2:	fc 4d       	sbci	r31, 0xDC	; 220
 cd4:	30 81       	ld	r19, Z
 cd6:	33 23       	and	r19, r19
 cd8:	79 f3       	breq	.-34     	; 0xcb8 <vTaskSwitchContext+0x38>
 cda:	ac 01       	movw	r20, r24
 cdc:	44 0f       	add	r20, r20
 cde:	55 1f       	adc	r21, r21
 ce0:	44 0f       	add	r20, r20
 ce2:	55 1f       	adc	r21, r21
 ce4:	44 0f       	add	r20, r20
 ce6:	55 1f       	adc	r21, r21
 ce8:	48 0f       	add	r20, r24
 cea:	59 1f       	adc	r21, r25
 cec:	da 01       	movw	r26, r20
 cee:	af 56       	subi	r26, 0x6F	; 111
 cf0:	bc 4d       	sbci	r27, 0xDC	; 220
 cf2:	11 96       	adiw	r26, 0x01	; 1
 cf4:	ed 91       	ld	r30, X+
 cf6:	fc 91       	ld	r31, X
 cf8:	12 97       	sbiw	r26, 0x02	; 2
 cfa:	02 80       	ldd	r0, Z+2	; 0x02
 cfc:	f3 81       	ldd	r31, Z+3	; 0x03
 cfe:	e0 2d       	mov	r30, r0
 d00:	11 96       	adiw	r26, 0x01	; 1
 d02:	ed 93       	st	X+, r30
 d04:	fc 93       	st	X, r31
 d06:	12 97       	sbiw	r26, 0x02	; 2
 d08:	4c 56       	subi	r20, 0x6C	; 108
 d0a:	5c 4d       	sbci	r21, 0xDC	; 220
 d0c:	e4 17       	cp	r30, r20
 d0e:	f5 07       	cpc	r31, r21
 d10:	29 f4       	brne	.+10     	; 0xd1c <vTaskSwitchContext+0x9c>
 d12:	42 81       	ldd	r20, Z+2	; 0x02
 d14:	53 81       	ldd	r21, Z+3	; 0x03
 d16:	fd 01       	movw	r30, r26
 d18:	41 83       	std	Z+1, r20	; 0x01
 d1a:	52 83       	std	Z+2, r21	; 0x02
 d1c:	fc 01       	movw	r30, r24
 d1e:	ee 0f       	add	r30, r30
 d20:	ff 1f       	adc	r31, r31
 d22:	ee 0f       	add	r30, r30
 d24:	ff 1f       	adc	r31, r31
 d26:	ee 0f       	add	r30, r30
 d28:	ff 1f       	adc	r31, r31
 d2a:	8e 0f       	add	r24, r30
 d2c:	9f 1f       	adc	r25, r31
 d2e:	fc 01       	movw	r30, r24
 d30:	ef 56       	subi	r30, 0x6F	; 111
 d32:	fc 4d       	sbci	r31, 0xDC	; 220
 d34:	01 80       	ldd	r0, Z+1	; 0x01
 d36:	f2 81       	ldd	r31, Z+2	; 0x02
 d38:	e0 2d       	mov	r30, r0
 d3a:	86 81       	ldd	r24, Z+6	; 0x06
 d3c:	97 81       	ldd	r25, Z+7	; 0x07
 d3e:	80 93 b5 23 	sts	0x23B5, r24
 d42:	90 93 b6 23 	sts	0x23B6, r25
 d46:	20 93 6e 23 	sts	0x236E, r18
 d4a:	08 95       	ret

00000d4c <thread_1>:
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
		t1var++;
		PORTR.OUTTGL = (1<<0);
 d4c:	00 ee       	ldi	r16, 0xE0	; 224
 d4e:	17 e0       	ldi	r17, 0x07	; 7
 d50:	c1 e0       	ldi	r28, 0x01	; 1
	//serial_startup();
	int i = 0;
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
 d52:	00 00       	nop
		t1var++;
 d54:	80 91 bb 23 	lds	r24, 0x23BB
 d58:	90 91 bc 23 	lds	r25, 0x23BC
 d5c:	01 96       	adiw	r24, 0x01	; 1
 d5e:	80 93 bb 23 	sts	0x23BB, r24
 d62:	90 93 bc 23 	sts	0x23BC, r25
		PORTR.OUTTGL = (1<<0);
 d66:	f8 01       	movw	r30, r16
 d68:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(1000); //wait 1 sec
 d6a:	88 ee       	ldi	r24, 0xE8	; 232
 d6c:	93 e0       	ldi	r25, 0x03	; 3
 d6e:	0e 94 2c 06 	call	0xc58	; 0xc58 <vTaskDelay>
	}
 d72:	ef cf       	rjmp	.-34     	; 0xd52 <thread_1+0x6>

00000d74 <thread_2>:
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
		t2var++;
		PORTR.OUTTGL = (1<<1);
 d74:	00 ee       	ldi	r16, 0xE0	; 224
 d76:	17 e0       	ldi	r17, 0x07	; 7
 d78:	c2 e0       	ldi	r28, 0x02	; 2
}
void thread_2( void *pvParameters ){
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
 d7a:	00 00       	nop
		t2var++;
 d7c:	80 91 b9 23 	lds	r24, 0x23B9
 d80:	90 91 ba 23 	lds	r25, 0x23BA
 d84:	01 96       	adiw	r24, 0x01	; 1
 d86:	80 93 b9 23 	sts	0x23B9, r24
 d8a:	90 93 ba 23 	sts	0x23BA, r25
		PORTR.OUTTGL = (1<<1);
 d8e:	f8 01       	movw	r30, r16
 d90:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(2000); //wait 2 seconds
 d92:	80 ed       	ldi	r24, 0xD0	; 208
 d94:	97 e0       	ldi	r25, 0x07	; 7
 d96:	0e 94 2c 06 	call	0xc58	; 0xc58 <vTaskDelay>
	}
 d9a:	ef cf       	rjmp	.-34     	; 0xd7a <thread_2+0x6>

00000d9c <thread_3>:
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
		t3var++;
		PORTD.OUTTGL = (1<<4);
 d9c:	00 e6       	ldi	r16, 0x60	; 96
 d9e:	16 e0       	ldi	r17, 0x06	; 6
 da0:	c0 e1       	ldi	r28, 0x10	; 16
}
void thread_3( void *pvParameters ){
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
 da2:	00 00       	nop
		t3var++;
 da4:	80 91 b7 23 	lds	r24, 0x23B7
 da8:	90 91 b8 23 	lds	r25, 0x23B8
 dac:	01 96       	adiw	r24, 0x01	; 1
 dae:	80 93 b7 23 	sts	0x23B7, r24
 db2:	90 93 b8 23 	sts	0x23B8, r25
		PORTD.OUTTGL = (1<<4);
 db6:	f8 01       	movw	r30, r16
 db8:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(200); //wait 200 ms
 dba:	88 ec       	ldi	r24, 0xC8	; 200
 dbc:	90 e0       	ldi	r25, 0x00	; 0
 dbe:	0e 94 2c 06 	call	0xc58	; 0xc58 <vTaskDelay>
	}
 dc2:	ef cf       	rjmp	.-34     	; 0xda2 <thread_3+0x6>

00000dc4 <main>:


int main(void)
{
	
	PORTR.DIRSET = (1<<0);
 dc4:	e0 ee       	ldi	r30, 0xE0	; 224
 dc6:	f7 e0       	ldi	r31, 0x07	; 7
 dc8:	81 e0       	ldi	r24, 0x01	; 1
 dca:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
 dcc:	82 e0       	ldi	r24, 0x02	; 2
 dce:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
 dd0:	80 e1       	ldi	r24, 0x10	; 16
 dd2:	80 93 61 06 	sts	0x0661, r24
	
	
	//creating the threads
	xTaskCreate(thread_1, (const char*) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
 dd6:	e1 2c       	mov	r14, r1
 dd8:	f1 2c       	mov	r15, r1
 dda:	00 e0       	ldi	r16, 0x00	; 0
 ddc:	20 e0       	ldi	r18, 0x00	; 0
 dde:	30 e0       	ldi	r19, 0x00	; 0
 de0:	4c e2       	ldi	r20, 0x2C	; 44
 de2:	51 e0       	ldi	r21, 0x01	; 1
 de4:	65 e0       	ldi	r22, 0x05	; 5
 de6:	70 e2       	ldi	r23, 0x20	; 32
 de8:	86 ea       	ldi	r24, 0xA6	; 166
 dea:	96 e0       	ldi	r25, 0x06	; 6
 dec:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskCreate>
	xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
 df0:	20 e0       	ldi	r18, 0x00	; 0
 df2:	30 e0       	ldi	r19, 0x00	; 0
 df4:	44 e6       	ldi	r20, 0x64	; 100
 df6:	50 e0       	ldi	r21, 0x00	; 0
 df8:	68 e0       	ldi	r22, 0x08	; 8
 dfa:	70 e2       	ldi	r23, 0x20	; 32
 dfc:	8a eb       	ldi	r24, 0xBA	; 186
 dfe:	96 e0       	ldi	r25, 0x06	; 6
 e00:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskCreate>
	xTaskCreate(thread_3,(const char *) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
 e04:	20 e0       	ldi	r18, 0x00	; 0
 e06:	30 e0       	ldi	r19, 0x00	; 0
 e08:	44 e6       	ldi	r20, 0x64	; 100
 e0a:	50 e0       	ldi	r21, 0x00	; 0
 e0c:	6b e0       	ldi	r22, 0x0B	; 11
 e0e:	70 e2       	ldi	r23, 0x20	; 32
 e10:	8e ec       	ldi	r24, 0xCE	; 206
 e12:	96 e0       	ldi	r25, 0x06	; 6
 e14:	0e 94 c1 03 	call	0x782	; 0x782 <xTaskCreate>
	
	
	//starting the scheduler
	vTaskStartScheduler();
 e18:	0e 94 c5 04 	call	0x98a	; 0x98a <vTaskStartScheduler>
	
    /* Replace with your application code */
    while (1) 
    {
    }
 e1c:	ff cf       	rjmp	.-2      	; 0xe1c <main+0x58>

00000e1e <_exit>:
 e1e:	f8 94       	cli

00000e20 <__stop_program>:
 e20:	ff cf       	rjmp	.-2      	; 0xe20 <__stop_program>
