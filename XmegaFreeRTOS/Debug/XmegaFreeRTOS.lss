
XmegaFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00802000  00000e44  00000ed8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ab  00802010  00802010  00000ee8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ee8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f18  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  00000f58  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003901  00000000  00000000  000011e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a7b  00000000  00000000  00004ae1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e6a  00000000  00000000  0000555c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005cc  00000000  00000000  000063c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000163f  00000000  00000000  00006994  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001647  00000000  00000000  00007fd3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000961a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 06 01 	jmp	0x20c	; 0x20c <__ctors_end>
   4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
   8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
   c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  10:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  14:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  18:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  1c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  20:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  24:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  28:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  2c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  30:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  34:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  38:	0c 94 fb 02 	jmp	0x5f6	; 0x5f6 <__vector_14>
  3c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  40:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  44:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  48:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  4c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  50:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  54:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  58:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  5c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  60:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  64:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  68:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  6c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  70:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  74:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  78:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  7c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  80:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  84:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  88:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  8c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  90:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  94:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  98:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  9c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  e8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  ec:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
  fc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 100:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 104:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 108:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 10c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 110:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 114:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 118:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 11c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 120:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 124:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 128:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 12c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 130:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 134:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 138:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 13c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 140:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 144:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 148:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 14c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 150:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 154:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 158:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 15c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 160:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 164:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 168:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 16c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 170:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 174:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 178:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 17c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 180:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 184:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 188:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 18c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 190:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 194:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 198:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 19c:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1a8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1ac:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1b8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1bc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1c8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1cc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1dc:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1e8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1ec:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f0:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f4:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>
 1f8:	0c 94 27 01 	jmp	0x24e	; 0x24e <__bad_interrupt>

000001fc <__trampolines_start>:
 1fc:	0c 94 29 01 	jmp	0x252	; 0x252 <thread_1>
 200:	0c 94 ca 03 	jmp	0x794	; 0x794 <prvIdleTask>
 204:	0c 94 3d 01 	jmp	0x27a	; 0x27a <thread_2>
 208:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <thread_3>

0000020c <__ctors_end>:
 20c:	11 24       	eor	r1, r1
 20e:	1f be       	out	0x3f, r1	; 63
 210:	cf ef       	ldi	r28, 0xFF	; 255
 212:	cd bf       	out	0x3d, r28	; 61
 214:	df e9       	ldi	r29, 0x9F	; 159
 216:	de bf       	out	0x3e, r29	; 62
 218:	00 e0       	ldi	r16, 0x00	; 0
 21a:	0c bf       	out	0x3c, r16	; 60

0000021c <__do_copy_data>:
 21c:	10 e2       	ldi	r17, 0x20	; 32
 21e:	a0 e0       	ldi	r26, 0x00	; 0
 220:	b0 e2       	ldi	r27, 0x20	; 32
 222:	e4 e4       	ldi	r30, 0x44	; 68
 224:	fe e0       	ldi	r31, 0x0E	; 14
 226:	00 e0       	ldi	r16, 0x00	; 0
 228:	0b bf       	out	0x3b, r16	; 59
 22a:	02 c0       	rjmp	.+4      	; 0x230 <__do_copy_data+0x14>
 22c:	07 90       	elpm	r0, Z+
 22e:	0d 92       	st	X+, r0
 230:	a0 31       	cpi	r26, 0x10	; 16
 232:	b1 07       	cpc	r27, r17
 234:	d9 f7       	brne	.-10     	; 0x22c <__do_copy_data+0x10>

00000236 <__do_clear_bss>:
 236:	23 e2       	ldi	r18, 0x23	; 35
 238:	a0 e1       	ldi	r26, 0x10	; 16
 23a:	b0 e2       	ldi	r27, 0x20	; 32
 23c:	01 c0       	rjmp	.+2      	; 0x240 <.do_clear_bss_start>

0000023e <.do_clear_bss_loop>:
 23e:	1d 92       	st	X+, r1

00000240 <.do_clear_bss_start>:
 240:	ab 3b       	cpi	r26, 0xBB	; 187
 242:	b2 07       	cpc	r27, r18
 244:	e1 f7       	brne	.-8      	; 0x23e <.do_clear_bss_loop>
 246:	0e 94 65 01 	call	0x2ca	; 0x2ca <main>
 24a:	0c 94 20 07 	jmp	0xe40	; 0xe40 <_exit>

0000024e <__bad_interrupt>:
 24e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000252 <thread_1>:
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
		t1var++;
		PORTR.OUTTGL = (1<<0);
 252:	00 ee       	ldi	r16, 0xE0	; 224
 254:	17 e0       	ldi	r17, 0x07	; 7
 256:	c1 e0       	ldi	r28, 0x01	; 1
	//serial_startup();
	int i = 0;
	while(1){
		//printf("hello world %d\n\r",i);
		//i++;
		asm("nop");
 258:	00 00       	nop
		t1var++;
 25a:	80 91 14 20 	lds	r24, 0x2014
 25e:	90 91 15 20 	lds	r25, 0x2015
 262:	01 96       	adiw	r24, 0x01	; 1
 264:	80 93 14 20 	sts	0x2014, r24
 268:	90 93 15 20 	sts	0x2015, r25
		PORTR.OUTTGL = (1<<0);
 26c:	f8 01       	movw	r30, r16
 26e:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(1000); //wait 1 sec
 270:	88 ee       	ldi	r24, 0xE8	; 232
 272:	93 e0       	ldi	r25, 0x03	; 3
 274:	0e 94 93 06 	call	0xd26	; 0xd26 <vTaskDelay>
	}
 278:	ef cf       	rjmp	.-34     	; 0x258 <thread_1+0x6>

0000027a <thread_2>:
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
		t2var++;
		PORTR.OUTTGL = (1<<1);
 27a:	00 ee       	ldi	r16, 0xE0	; 224
 27c:	17 e0       	ldi	r17, 0x07	; 7
 27e:	c2 e0       	ldi	r28, 0x02	; 2
}
void thread_2( void *pvParameters ){
	//DDRB |= (1<<DDB0); //set PORTB, PIN0 as output
	while(1){
		//PORTB ^= (1<<PORTB0); //toggle PORTB, PIN0
		asm("nop");
 280:	00 00       	nop
		t2var++;
 282:	80 91 12 20 	lds	r24, 0x2012
 286:	90 91 13 20 	lds	r25, 0x2013
 28a:	01 96       	adiw	r24, 0x01	; 1
 28c:	80 93 12 20 	sts	0x2012, r24
 290:	90 93 13 20 	sts	0x2013, r25
		PORTR.OUTTGL = (1<<1);
 294:	f8 01       	movw	r30, r16
 296:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(2000); //wait 2 seconds
 298:	80 ed       	ldi	r24, 0xD0	; 208
 29a:	97 e0       	ldi	r25, 0x07	; 7
 29c:	0e 94 93 06 	call	0xd26	; 0xd26 <vTaskDelay>
	}
 2a0:	ef cf       	rjmp	.-34     	; 0x280 <thread_2+0x6>

000002a2 <thread_3>:
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
		t3var++;
		PORTD.OUTTGL = (1<<4);
 2a2:	00 e6       	ldi	r16, 0x60	; 96
 2a4:	16 e0       	ldi	r17, 0x06	; 6
 2a6:	c0 e1       	ldi	r28, 0x10	; 16
}
void thread_3( void *pvParameters ){
	//DDRB |= (1<<DDB1); //set PORTB, PIN1 as output
	while(1){
		//PORTB ^= (1<<PORTB1); //togle PORTB, PIN0
		asm("nop");
 2a8:	00 00       	nop
		t3var++;
 2aa:	80 91 10 20 	lds	r24, 0x2010
 2ae:	90 91 11 20 	lds	r25, 0x2011
 2b2:	01 96       	adiw	r24, 0x01	; 1
 2b4:	80 93 10 20 	sts	0x2010, r24
 2b8:	90 93 11 20 	sts	0x2011, r25
		PORTD.OUTTGL = (1<<4);
 2bc:	f8 01       	movw	r30, r16
 2be:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(200); //wait 200 ms
 2c0:	88 ec       	ldi	r24, 0xC8	; 200
 2c2:	90 e0       	ldi	r25, 0x00	; 0
 2c4:	0e 94 93 06 	call	0xd26	; 0xd26 <vTaskDelay>
	}
 2c8:	ef cf       	rjmp	.-34     	; 0x2a8 <thread_3+0x6>

000002ca <main>:


int main(void)
{
	
	PORTR.DIRSET = (1<<0);
 2ca:	e0 ee       	ldi	r30, 0xE0	; 224
 2cc:	f7 e0       	ldi	r31, 0x07	; 7
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	81 83       	std	Z+1, r24	; 0x01
	PORTR.DIRSET = (1<<1);
 2d2:	82 e0       	ldi	r24, 0x02	; 2
 2d4:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = (1<<4);
 2d6:	80 e1       	ldi	r24, 0x10	; 16
 2d8:	80 93 61 06 	sts	0x0661, r24
	
	
	//creating the threads
	xTaskCreate(thread_1, (const char*) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
 2dc:	a1 2c       	mov	r10, r1
 2de:	b1 2c       	mov	r11, r1
 2e0:	c1 2c       	mov	r12, r1
 2e2:	d1 2c       	mov	r13, r1
 2e4:	e1 2c       	mov	r14, r1
 2e6:	f1 2c       	mov	r15, r1
 2e8:	00 e0       	ldi	r16, 0x00	; 0
 2ea:	20 e0       	ldi	r18, 0x00	; 0
 2ec:	30 e0       	ldi	r19, 0x00	; 0
 2ee:	4c e2       	ldi	r20, 0x2C	; 44
 2f0:	51 e0       	ldi	r21, 0x01	; 1
 2f2:	62 e0       	ldi	r22, 0x02	; 2
 2f4:	70 e2       	ldi	r23, 0x20	; 32
 2f6:	89 e2       	ldi	r24, 0x29	; 41
 2f8:	91 e0       	ldi	r25, 0x01	; 1
 2fa:	0e 94 02 04 	call	0x804	; 0x804 <xTaskGenericCreate>
	xTaskCreate(thread_2,(const char *) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
 2fe:	20 e0       	ldi	r18, 0x00	; 0
 300:	30 e0       	ldi	r19, 0x00	; 0
 302:	44 e6       	ldi	r20, 0x64	; 100
 304:	50 e0       	ldi	r21, 0x00	; 0
 306:	65 e0       	ldi	r22, 0x05	; 5
 308:	70 e2       	ldi	r23, 0x20	; 32
 30a:	8d e3       	ldi	r24, 0x3D	; 61
 30c:	91 e0       	ldi	r25, 0x01	; 1
 30e:	0e 94 02 04 	call	0x804	; 0x804 <xTaskGenericCreate>
	xTaskCreate(thread_3,(const char *) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
 312:	20 e0       	ldi	r18, 0x00	; 0
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	44 e6       	ldi	r20, 0x64	; 100
 318:	50 e0       	ldi	r21, 0x00	; 0
 31a:	68 e0       	ldi	r22, 0x08	; 8
 31c:	70 e2       	ldi	r23, 0x20	; 32
 31e:	81 e5       	ldi	r24, 0x51	; 81
 320:	91 e0       	ldi	r25, 0x01	; 1
 322:	0e 94 02 04 	call	0x804	; 0x804 <xTaskGenericCreate>
	
	
	//starting the scheduler
	vTaskStartScheduler();
 326:	0e 94 0a 05 	call	0xa14	; 0xa14 <vTaskStartScheduler>
	
    /* Replace with your application code */
    while (1) 
    {
    }
 32a:	ff cf       	rjmp	.-2      	; 0x32a <main+0x60>

0000032c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 32c:	31 e1       	ldi	r19, 0x11	; 17
 32e:	fc 01       	movw	r30, r24
 330:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	22 e2       	ldi	r18, 0x22	; 34
 336:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	a3 e3       	ldi	r26, 0x33	; 51
 33c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__
	*pxTopOfStack = (portSTACK_TYPE ) 0;
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 34e:	31 97       	sbiw	r30, 0x01	; 1
 350:	60 e8       	ldi	r22, 0x80	; 128
 352:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	62 e0       	ldi	r22, 0x02	; 2
 35c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	63 e0       	ldi	r22, 0x03	; 3
 362:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	64 e0       	ldi	r22, 0x04	; 4
 368:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	65 e0       	ldi	r22, 0x05	; 5
 36e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	66 e0       	ldi	r22, 0x06	; 6
 374:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 376:	31 97       	sbiw	r30, 0x01	; 1
 378:	67 e0       	ldi	r22, 0x07	; 7
 37a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 37c:	31 97       	sbiw	r30, 0x01	; 1
 37e:	68 e0       	ldi	r22, 0x08	; 8
 380:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 382:	31 97       	sbiw	r30, 0x01	; 1
 384:	69 e0       	ldi	r22, 0x09	; 9
 386:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 388:	31 97       	sbiw	r30, 0x01	; 1
 38a:	60 e1       	ldi	r22, 0x10	; 16
 38c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	32 e1       	ldi	r19, 0x12	; 18
 396:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	33 e1       	ldi	r19, 0x13	; 19
 39c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	34 e1       	ldi	r19, 0x14	; 20
 3a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	35 e1       	ldi	r19, 0x15	; 21
 3a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 3aa:	31 97       	sbiw	r30, 0x01	; 1
 3ac:	36 e1       	ldi	r19, 0x16	; 22
 3ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 3b0:	31 97       	sbiw	r30, 0x01	; 1
 3b2:	37 e1       	ldi	r19, 0x17	; 23
 3b4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 3b6:	31 97       	sbiw	r30, 0x01	; 1
 3b8:	38 e1       	ldi	r19, 0x18	; 24
 3ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 3bc:	31 97       	sbiw	r30, 0x01	; 1
 3be:	39 e1       	ldi	r19, 0x19	; 25
 3c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 3c2:	31 97       	sbiw	r30, 0x01	; 1
 3c4:	30 e2       	ldi	r19, 0x20	; 32
 3c6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	31 e2       	ldi	r19, 0x21	; 33
 3cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 3d2:	31 97       	sbiw	r30, 0x01	; 1
 3d4:	23 e2       	ldi	r18, 0x23	; 35
 3d6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 3dc:	31 97       	sbiw	r30, 0x01	; 1
 3de:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 3e0:	31 97       	sbiw	r30, 0x01	; 1
 3e2:	26 e2       	ldi	r18, 0x26	; 38
 3e4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 3e6:	31 97       	sbiw	r30, 0x01	; 1
 3e8:	27 e2       	ldi	r18, 0x27	; 39
 3ea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 3ec:	31 97       	sbiw	r30, 0x01	; 1
 3ee:	28 e2       	ldi	r18, 0x28	; 40
 3f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 3f2:	31 97       	sbiw	r30, 0x01	; 1
 3f4:	29 e2       	ldi	r18, 0x29	; 41
 3f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	20 e3       	ldi	r18, 0x30	; 48
 3fc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 3fe:	31 97       	sbiw	r30, 0x01	; 1
 400:	21 e3       	ldi	r18, 0x31	; 49
 402:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 404:	87 97       	sbiw	r24, 0x27	; 39
 406:	08 95       	ret

00000408 <xPortStartScheduler>:
static void prvSetupTimerInterrupt( void )
{
    //Use TCC0 as a tick counter. If this is to be changed, change ISR as well
    TC0_t * tickTimer = &TCC0;
    //select the clock source and pre-scale by 64
    TC0_ConfigClockSource(tickTimer, TC_CLKSEL_DIV64_gc);
 408:	65 e0       	ldi	r22, 0x05	; 5
 40a:	80 e0       	ldi	r24, 0x00	; 0
 40c:	98 e0       	ldi	r25, 0x08	; 8
 40e:	0e 94 fe 02 	call	0x5fc	; 0x5fc <TC0_ConfigClockSource>
    //set period of counter
    tickTimer->PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 64 - 1;
 412:	8e e1       	ldi	r24, 0x1E	; 30
 414:	90 e0       	ldi	r25, 0x00	; 0
 416:	80 93 26 08 	sts	0x0826, r24
 41a:	90 93 27 08 	sts	0x0827, r25

    //enable interrupt and set low level
    TC0_SetOverflowIntLevel(tickTimer, TC_OVFINTLVL_LO_gc);
 41e:	61 e0       	ldi	r22, 0x01	; 1
 420:	80 e0       	ldi	r24, 0x00	; 0
 422:	98 e0       	ldi	r25, 0x08	; 8
 424:	0e 94 04 03 	call	0x608	; 0x608 <TC0_SetOverflowIntLevel>
    //enable low level interrupts
    PMIC_EnableLowLevel();
 428:	e0 ea       	ldi	r30, 0xA0	; 160
 42a:	f0 e0       	ldi	r31, 0x00	; 0
 42c:	82 81       	ldd	r24, Z+2	; 0x02
 42e:	81 60       	ori	r24, 0x01	; 1
 430:	82 83       	std	Z+2, r24	; 0x02
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 432:	a0 91 b9 23 	lds	r26, 0x23B9
 436:	b0 91 ba 23 	lds	r27, 0x23BA
 43a:	cd 91       	ld	r28, X+
 43c:	cd bf       	out	0x3d, r28	; 61
 43e:	dd 91       	ld	r29, X+
 440:	de bf       	out	0x3e, r29	; 62
 442:	ff 91       	pop	r31
 444:	ef 91       	pop	r30
 446:	df 91       	pop	r29
 448:	cf 91       	pop	r28
 44a:	bf 91       	pop	r27
 44c:	af 91       	pop	r26
 44e:	9f 91       	pop	r25
 450:	8f 91       	pop	r24
 452:	7f 91       	pop	r23
 454:	6f 91       	pop	r22
 456:	5f 91       	pop	r21
 458:	4f 91       	pop	r20
 45a:	3f 91       	pop	r19
 45c:	2f 91       	pop	r18
 45e:	1f 91       	pop	r17
 460:	0f 91       	pop	r16
 462:	ff 90       	pop	r15
 464:	ef 90       	pop	r14
 466:	df 90       	pop	r13
 468:	cf 90       	pop	r12
 46a:	bf 90       	pop	r11
 46c:	af 90       	pop	r10
 46e:	9f 90       	pop	r9
 470:	8f 90       	pop	r8
 472:	7f 90       	pop	r7
 474:	6f 90       	pop	r6
 476:	5f 90       	pop	r5
 478:	4f 90       	pop	r4
 47a:	3f 90       	pop	r3
 47c:	2f 90       	pop	r2
 47e:	1f 90       	pop	r1
 480:	0f 90       	pop	r0
 482:	0f be       	out	0x3f, r0	; 63
 484:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 486:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 488:	81 e0       	ldi	r24, 0x01	; 1
 48a:	08 95       	ret

0000048c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 48c:	0f 92       	push	r0
 48e:	0f b6       	in	r0, 0x3f	; 63
 490:	f8 94       	cli
 492:	0f 92       	push	r0
 494:	1f 92       	push	r1
 496:	11 24       	eor	r1, r1
 498:	2f 92       	push	r2
 49a:	3f 92       	push	r3
 49c:	4f 92       	push	r4
 49e:	5f 92       	push	r5
 4a0:	6f 92       	push	r6
 4a2:	7f 92       	push	r7
 4a4:	8f 92       	push	r8
 4a6:	9f 92       	push	r9
 4a8:	af 92       	push	r10
 4aa:	bf 92       	push	r11
 4ac:	cf 92       	push	r12
 4ae:	df 92       	push	r13
 4b0:	ef 92       	push	r14
 4b2:	ff 92       	push	r15
 4b4:	0f 93       	push	r16
 4b6:	1f 93       	push	r17
 4b8:	2f 93       	push	r18
 4ba:	3f 93       	push	r19
 4bc:	4f 93       	push	r20
 4be:	5f 93       	push	r21
 4c0:	6f 93       	push	r22
 4c2:	7f 93       	push	r23
 4c4:	8f 93       	push	r24
 4c6:	9f 93       	push	r25
 4c8:	af 93       	push	r26
 4ca:	bf 93       	push	r27
 4cc:	cf 93       	push	r28
 4ce:	df 93       	push	r29
 4d0:	ef 93       	push	r30
 4d2:	ff 93       	push	r31
 4d4:	a0 91 b9 23 	lds	r26, 0x23B9
 4d8:	b0 91 ba 23 	lds	r27, 0x23BA
 4dc:	0d b6       	in	r0, 0x3d	; 61
 4de:	0d 92       	st	X+, r0
 4e0:	0e b6       	in	r0, 0x3e	; 62
 4e2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4e4:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4e8:	a0 91 b9 23 	lds	r26, 0x23B9
 4ec:	b0 91 ba 23 	lds	r27, 0x23BA
 4f0:	cd 91       	ld	r28, X+
 4f2:	cd bf       	out	0x3d, r28	; 61
 4f4:	dd 91       	ld	r29, X+
 4f6:	de bf       	out	0x3e, r29	; 62
 4f8:	ff 91       	pop	r31
 4fa:	ef 91       	pop	r30
 4fc:	df 91       	pop	r29
 4fe:	cf 91       	pop	r28
 500:	bf 91       	pop	r27
 502:	af 91       	pop	r26
 504:	9f 91       	pop	r25
 506:	8f 91       	pop	r24
 508:	7f 91       	pop	r23
 50a:	6f 91       	pop	r22
 50c:	5f 91       	pop	r21
 50e:	4f 91       	pop	r20
 510:	3f 91       	pop	r19
 512:	2f 91       	pop	r18
 514:	1f 91       	pop	r17
 516:	0f 91       	pop	r16
 518:	ff 90       	pop	r15
 51a:	ef 90       	pop	r14
 51c:	df 90       	pop	r13
 51e:	cf 90       	pop	r12
 520:	bf 90       	pop	r11
 522:	af 90       	pop	r10
 524:	9f 90       	pop	r9
 526:	8f 90       	pop	r8
 528:	7f 90       	pop	r7
 52a:	6f 90       	pop	r6
 52c:	5f 90       	pop	r5
 52e:	4f 90       	pop	r4
 530:	3f 90       	pop	r3
 532:	2f 90       	pop	r2
 534:	1f 90       	pop	r1
 536:	0f 90       	pop	r0
 538:	0f be       	out	0x3f, r0	; 63
 53a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 53c:	08 95       	ret

0000053e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 53e:	0f 92       	push	r0
 540:	0f b6       	in	r0, 0x3f	; 63
 542:	f8 94       	cli
 544:	0f 92       	push	r0
 546:	1f 92       	push	r1
 548:	11 24       	eor	r1, r1
 54a:	2f 92       	push	r2
 54c:	3f 92       	push	r3
 54e:	4f 92       	push	r4
 550:	5f 92       	push	r5
 552:	6f 92       	push	r6
 554:	7f 92       	push	r7
 556:	8f 92       	push	r8
 558:	9f 92       	push	r9
 55a:	af 92       	push	r10
 55c:	bf 92       	push	r11
 55e:	cf 92       	push	r12
 560:	df 92       	push	r13
 562:	ef 92       	push	r14
 564:	ff 92       	push	r15
 566:	0f 93       	push	r16
 568:	1f 93       	push	r17
 56a:	2f 93       	push	r18
 56c:	3f 93       	push	r19
 56e:	4f 93       	push	r20
 570:	5f 93       	push	r21
 572:	6f 93       	push	r22
 574:	7f 93       	push	r23
 576:	8f 93       	push	r24
 578:	9f 93       	push	r25
 57a:	af 93       	push	r26
 57c:	bf 93       	push	r27
 57e:	cf 93       	push	r28
 580:	df 93       	push	r29
 582:	ef 93       	push	r30
 584:	ff 93       	push	r31
 586:	a0 91 b9 23 	lds	r26, 0x23B9
 58a:	b0 91 ba 23 	lds	r27, 0x23BA
 58e:	0d b6       	in	r0, 0x3d	; 61
 590:	0d 92       	st	X+, r0
 592:	0e b6       	in	r0, 0x3e	; 62
 594:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 596:	0e 94 3b 05 	call	0xa76	; 0xa76 <xTaskIncrementTick>
 59a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 59c:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 5a0:	a0 91 b9 23 	lds	r26, 0x23B9
 5a4:	b0 91 ba 23 	lds	r27, 0x23BA
 5a8:	cd 91       	ld	r28, X+
 5aa:	cd bf       	out	0x3d, r28	; 61
 5ac:	dd 91       	ld	r29, X+
 5ae:	de bf       	out	0x3e, r29	; 62
 5b0:	ff 91       	pop	r31
 5b2:	ef 91       	pop	r30
 5b4:	df 91       	pop	r29
 5b6:	cf 91       	pop	r28
 5b8:	bf 91       	pop	r27
 5ba:	af 91       	pop	r26
 5bc:	9f 91       	pop	r25
 5be:	8f 91       	pop	r24
 5c0:	7f 91       	pop	r23
 5c2:	6f 91       	pop	r22
 5c4:	5f 91       	pop	r21
 5c6:	4f 91       	pop	r20
 5c8:	3f 91       	pop	r19
 5ca:	2f 91       	pop	r18
 5cc:	1f 91       	pop	r17
 5ce:	0f 91       	pop	r16
 5d0:	ff 90       	pop	r15
 5d2:	ef 90       	pop	r14
 5d4:	df 90       	pop	r13
 5d6:	cf 90       	pop	r12
 5d8:	bf 90       	pop	r11
 5da:	af 90       	pop	r10
 5dc:	9f 90       	pop	r9
 5de:	8f 90       	pop	r8
 5e0:	7f 90       	pop	r7
 5e2:	6f 90       	pop	r6
 5e4:	5f 90       	pop	r5
 5e6:	4f 90       	pop	r4
 5e8:	3f 90       	pop	r3
 5ea:	2f 90       	pop	r2
 5ec:	1f 90       	pop	r1
 5ee:	0f 90       	pop	r0
 5f0:	0f be       	out	0x3f, r0	; 63
 5f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5f4:	08 95       	ret

000005f6 <__vector_14>:
	 */
	
	void TCC0_OVF_vect( void ) __attribute__ ( ( signal, naked ) );
	void TCC0_OVF_vect( void )
	{
		vPortYieldFromTick();
 5f6:	0e 94 9f 02 	call	0x53e	; 0x53e <vPortYieldFromTick>
		asm volatile ( "reti" );
 5fa:	18 95       	reti

000005fc <TC0_ConfigClockSource>:
 *
 *  \param tc              Timer/Counter module instance.
 *  \param clockSelection  Timer/Counter clock source setting.
 */
void TC0_ConfigClockSource( volatile TC0_t * tc, TC_CLKSEL_t clockSelection )
{
 5fc:	fc 01       	movw	r30, r24
	tc->CTRLA = ( tc->CTRLA & ~TC0_CLKSEL_gm ) | clockSelection;
 5fe:	90 81       	ld	r25, Z
 600:	90 7f       	andi	r25, 0xF0	; 240
 602:	69 2b       	or	r22, r25
 604:	60 83       	st	Z, r22
 606:	08 95       	ret

00000608 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
 608:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
 60a:	96 81       	ldd	r25, Z+6	; 0x06
 60c:	9c 7f       	andi	r25, 0xFC	; 252
 60e:	69 2b       	or	r22, r25
 610:	66 83       	std	Z+6, r22	; 0x06
 612:	08 95       	ret

00000614 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 614:	cf 93       	push	r28
 616:	df 93       	push	r29
 618:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 61a:	0e 94 35 05 	call	0xa6a	; 0xa6a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 61e:	80 91 16 20 	lds	r24, 0x2016
 622:	90 91 17 20 	lds	r25, 0x2017
 626:	89 2b       	or	r24, r25
 628:	31 f4       	brne	.+12     	; 0x636 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 62a:	8b e1       	ldi	r24, 0x1B	; 27
 62c:	90 e2       	ldi	r25, 0x20	; 32
 62e:	80 93 16 20 	sts	0x2016, r24
 632:	90 93 17 20 	sts	0x2017, r25
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 636:	20 91 18 20 	lds	r18, 0x2018
 63a:	30 91 19 20 	lds	r19, 0x2019
 63e:	ce 01       	movw	r24, r28
 640:	82 0f       	add	r24, r18
 642:	93 1f       	adc	r25, r19
 644:	81 35       	cpi	r24, 0x51	; 81
 646:	43 e0       	ldi	r20, 0x03	; 3
 648:	94 07       	cpc	r25, r20
 64a:	70 f4       	brcc	.+28     	; 0x668 <pvPortMalloc+0x54>
 64c:	28 17       	cp	r18, r24
 64e:	39 07       	cpc	r19, r25
 650:	70 f4       	brcc	.+28     	; 0x66e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 652:	c0 91 16 20 	lds	r28, 0x2016
 656:	d0 91 17 20 	lds	r29, 0x2017
 65a:	c2 0f       	add	r28, r18
 65c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 65e:	80 93 18 20 	sts	0x2018, r24
 662:	90 93 19 20 	sts	0x2019, r25
 666:	05 c0       	rjmp	.+10     	; 0x672 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 668:	c0 e0       	ldi	r28, 0x00	; 0
 66a:	d0 e0       	ldi	r29, 0x00	; 0
 66c:	02 c0       	rjmp	.+4      	; 0x672 <pvPortMalloc+0x5e>
 66e:	c0 e0       	ldi	r28, 0x00	; 0
 670:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 672:	0e 94 11 06 	call	0xc22	; 0xc22 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 676:	ce 01       	movw	r24, r28
 678:	df 91       	pop	r29
 67a:	cf 91       	pop	r28
 67c:	08 95       	ret

0000067e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 67e:	08 95       	ret

00000680 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 680:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 682:	03 96       	adiw	r24, 0x03	; 3
 684:	81 83       	std	Z+1, r24	; 0x01
 686:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 688:	2f ef       	ldi	r18, 0xFF	; 255
 68a:	3f ef       	ldi	r19, 0xFF	; 255
 68c:	23 83       	std	Z+3, r18	; 0x03
 68e:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 690:	85 83       	std	Z+5, r24	; 0x05
 692:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 694:	87 83       	std	Z+7, r24	; 0x07
 696:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 698:	10 82       	st	Z, r1
 69a:	08 95       	ret

0000069c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 69c:	fc 01       	movw	r30, r24
 69e:	10 86       	std	Z+8, r1	; 0x08
 6a0:	11 86       	std	Z+9, r1	; 0x09
 6a2:	08 95       	ret

000006a4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 6a4:	cf 93       	push	r28
 6a6:	df 93       	push	r29
 6a8:	9c 01       	movw	r18, r24
 6aa:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 6ac:	dc 01       	movw	r26, r24
 6ae:	11 96       	adiw	r26, 0x01	; 1
 6b0:	cd 91       	ld	r28, X+
 6b2:	dc 91       	ld	r29, X
 6b4:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 6b6:	c2 83       	std	Z+2, r28	; 0x02
 6b8:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 6ba:	8c 81       	ldd	r24, Y+4	; 0x04
 6bc:	9d 81       	ldd	r25, Y+5	; 0x05
 6be:	84 83       	std	Z+4, r24	; 0x04
 6c0:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 6c2:	8c 81       	ldd	r24, Y+4	; 0x04
 6c4:	9d 81       	ldd	r25, Y+5	; 0x05
 6c6:	dc 01       	movw	r26, r24
 6c8:	12 96       	adiw	r26, 0x02	; 2
 6ca:	6d 93       	st	X+, r22
 6cc:	7c 93       	st	X, r23
 6ce:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
 6d0:	6c 83       	std	Y+4, r22	; 0x04
 6d2:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 6d4:	20 87       	std	Z+8, r18	; 0x08
 6d6:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
 6d8:	f9 01       	movw	r30, r18
 6da:	80 81       	ld	r24, Z
 6dc:	8f 5f       	subi	r24, 0xFF	; 255
 6de:	80 83       	st	Z, r24
}
 6e0:	df 91       	pop	r29
 6e2:	cf 91       	pop	r28
 6e4:	08 95       	ret

000006e6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 6e6:	cf 93       	push	r28
 6e8:	df 93       	push	r29
 6ea:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 6ec:	48 81       	ld	r20, Y
 6ee:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 6f0:	4f 3f       	cpi	r20, 0xFF	; 255
 6f2:	2f ef       	ldi	r18, 0xFF	; 255
 6f4:	52 07       	cpc	r21, r18
 6f6:	21 f4       	brne	.+8      	; 0x700 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 6f8:	fc 01       	movw	r30, r24
 6fa:	a7 81       	ldd	r26, Z+7	; 0x07
 6fc:	b0 85       	ldd	r27, Z+8	; 0x08
 6fe:	0d c0       	rjmp	.+26     	; 0x71a <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 700:	dc 01       	movw	r26, r24
 702:	13 96       	adiw	r26, 0x03	; 3
 704:	01 c0       	rjmp	.+2      	; 0x708 <vListInsert+0x22>
 706:	df 01       	movw	r26, r30
 708:	12 96       	adiw	r26, 0x02	; 2
 70a:	ed 91       	ld	r30, X+
 70c:	fc 91       	ld	r31, X
 70e:	13 97       	sbiw	r26, 0x03	; 3
 710:	20 81       	ld	r18, Z
 712:	31 81       	ldd	r19, Z+1	; 0x01
 714:	42 17       	cp	r20, r18
 716:	53 07       	cpc	r21, r19
 718:	b0 f7       	brcc	.-20     	; 0x706 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 71a:	12 96       	adiw	r26, 0x02	; 2
 71c:	ed 91       	ld	r30, X+
 71e:	fc 91       	ld	r31, X
 720:	13 97       	sbiw	r26, 0x03	; 3
 722:	ea 83       	std	Y+2, r30	; 0x02
 724:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 726:	c4 83       	std	Z+4, r28	; 0x04
 728:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
 72a:	ac 83       	std	Y+4, r26	; 0x04
 72c:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
 72e:	12 96       	adiw	r26, 0x02	; 2
 730:	cd 93       	st	X+, r28
 732:	dc 93       	st	X, r29
 734:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 736:	88 87       	std	Y+8, r24	; 0x08
 738:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
 73a:	fc 01       	movw	r30, r24
 73c:	20 81       	ld	r18, Z
 73e:	2f 5f       	subi	r18, 0xFF	; 255
 740:	20 83       	st	Z, r18
}
 742:	df 91       	pop	r29
 744:	cf 91       	pop	r28
 746:	08 95       	ret

00000748 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 748:	cf 93       	push	r28
 74a:	df 93       	push	r29
 74c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 74e:	a0 85       	ldd	r26, Z+8	; 0x08
 750:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 752:	c2 81       	ldd	r28, Z+2	; 0x02
 754:	d3 81       	ldd	r29, Z+3	; 0x03
 756:	84 81       	ldd	r24, Z+4	; 0x04
 758:	95 81       	ldd	r25, Z+5	; 0x05
 75a:	8c 83       	std	Y+4, r24	; 0x04
 75c:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 75e:	c4 81       	ldd	r28, Z+4	; 0x04
 760:	d5 81       	ldd	r29, Z+5	; 0x05
 762:	82 81       	ldd	r24, Z+2	; 0x02
 764:	93 81       	ldd	r25, Z+3	; 0x03
 766:	8a 83       	std	Y+2, r24	; 0x02
 768:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 76a:	11 96       	adiw	r26, 0x01	; 1
 76c:	cd 91       	ld	r28, X+
 76e:	dc 91       	ld	r29, X
 770:	12 97       	sbiw	r26, 0x02	; 2
 772:	ce 17       	cp	r28, r30
 774:	df 07       	cpc	r29, r31
 776:	31 f4       	brne	.+12     	; 0x784 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 778:	8c 81       	ldd	r24, Y+4	; 0x04
 77a:	9d 81       	ldd	r25, Y+5	; 0x05
 77c:	11 96       	adiw	r26, 0x01	; 1
 77e:	8d 93       	st	X+, r24
 780:	9c 93       	st	X, r25
 782:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 784:	10 86       	std	Z+8, r1	; 0x08
 786:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
 788:	8c 91       	ld	r24, X
 78a:	81 50       	subi	r24, 0x01	; 1
 78c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 78e:	df 91       	pop	r29
 790:	cf 91       	pop	r28
 792:	08 95       	ret

00000794 <prvIdleTask>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 794:	ff cf       	rjmp	.-2      	; 0x794 <prvIdleTask>

00000796 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 796:	cf 93       	push	r28
 798:	df 93       	push	r29
 79a:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 79c:	e0 91 b9 23 	lds	r30, 0x23B9
 7a0:	f0 91 ba 23 	lds	r31, 0x23BA
 7a4:	82 83       	std	Z+2, r24	; 0x02
 7a6:	93 83       	std	Z+3, r25	; 0x03

	if( xTimeToWake < xTickCount )
 7a8:	80 91 73 23 	lds	r24, 0x2373
 7ac:	90 91 74 23 	lds	r25, 0x2374
 7b0:	c8 17       	cp	r28, r24
 7b2:	d9 07       	cpc	r29, r25
 7b4:	68 f4       	brcc	.+26     	; 0x7d0 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 7b6:	60 91 b9 23 	lds	r22, 0x23B9
 7ba:	70 91 ba 23 	lds	r23, 0x23BA
 7be:	80 91 7f 23 	lds	r24, 0x237F
 7c2:	90 91 80 23 	lds	r25, 0x2380
 7c6:	6e 5f       	subi	r22, 0xFE	; 254
 7c8:	7f 4f       	sbci	r23, 0xFF	; 255
 7ca:	0e 94 73 03 	call	0x6e6	; 0x6e6 <vListInsert>
 7ce:	17 c0       	rjmp	.+46     	; 0x7fe <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 7d0:	60 91 b9 23 	lds	r22, 0x23B9
 7d4:	70 91 ba 23 	lds	r23, 0x23BA
 7d8:	80 91 81 23 	lds	r24, 0x2381
 7dc:	90 91 82 23 	lds	r25, 0x2382
 7e0:	6e 5f       	subi	r22, 0xFE	; 254
 7e2:	7f 4f       	sbci	r23, 0xFF	; 255
 7e4:	0e 94 73 03 	call	0x6e6	; 0x6e6 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 7e8:	80 91 00 20 	lds	r24, 0x2000
 7ec:	90 91 01 20 	lds	r25, 0x2001
 7f0:	c8 17       	cp	r28, r24
 7f2:	d9 07       	cpc	r29, r25
 7f4:	20 f4       	brcc	.+8      	; 0x7fe <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
 7f6:	c0 93 00 20 	sts	0x2000, r28
 7fa:	d0 93 01 20 	sts	0x2001, r29
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 7fe:	df 91       	pop	r29
 800:	cf 91       	pop	r28
 802:	08 95       	ret

00000804 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 804:	4f 92       	push	r4
 806:	5f 92       	push	r5
 808:	6f 92       	push	r6
 80a:	7f 92       	push	r7
 80c:	8f 92       	push	r8
 80e:	9f 92       	push	r9
 810:	af 92       	push	r10
 812:	bf 92       	push	r11
 814:	cf 92       	push	r12
 816:	df 92       	push	r13
 818:	ef 92       	push	r14
 81a:	ff 92       	push	r15
 81c:	0f 93       	push	r16
 81e:	1f 93       	push	r17
 820:	cf 93       	push	r28
 822:	df 93       	push	r29
 824:	4c 01       	movw	r8, r24
 826:	eb 01       	movw	r28, r22
 828:	5a 01       	movw	r10, r20
 82a:	29 01       	movw	r4, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 82c:	81 e2       	ldi	r24, 0x21	; 33
 82e:	90 e0       	ldi	r25, 0x00	; 0
 830:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
 834:	3c 01       	movw	r6, r24

	if( pxNewTCB != NULL )
 836:	00 97       	sbiw	r24, 0x00	; 0
 838:	09 f4       	brne	.+2      	; 0x83c <xTaskGenericCreate+0x38>
 83a:	da c0       	rjmp	.+436    	; 0x9f0 <xTaskGenericCreate+0x1ec>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 83c:	c1 14       	cp	r12, r1
 83e:	d1 04       	cpc	r13, r1
 840:	09 f0       	breq	.+2      	; 0x844 <xTaskGenericCreate+0x40>
 842:	d2 c0       	rjmp	.+420    	; 0x9e8 <xTaskGenericCreate+0x1e4>
 844:	c5 01       	movw	r24, r10
 846:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
 84a:	f3 01       	movw	r30, r6
 84c:	87 8b       	std	Z+23, r24	; 0x17
 84e:	90 8f       	std	Z+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
 850:	89 2b       	or	r24, r25
 852:	21 f4       	brne	.+8      	; 0x85c <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 854:	c3 01       	movw	r24, r6
 856:	0e 94 3f 03 	call	0x67e	; 0x67e <vPortFree>
 85a:	ca c0       	rjmp	.+404    	; 0x9f0 <xTaskGenericCreate+0x1ec>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 85c:	f1 e0       	ldi	r31, 0x01	; 1
 85e:	af 1a       	sub	r10, r31
 860:	b1 08       	sbc	r11, r1
 862:	f3 01       	movw	r30, r6
 864:	87 89       	ldd	r24, Z+23	; 0x17
 866:	90 8d       	ldd	r25, Z+24	; 0x18
 868:	a8 0e       	add	r10, r24
 86a:	b9 1e       	adc	r11, r25
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 86c:	88 81       	ld	r24, Y
 86e:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 870:	88 81       	ld	r24, Y
 872:	88 23       	and	r24, r24
 874:	81 f0       	breq	.+32     	; 0x896 <xTaskGenericCreate+0x92>
 876:	d3 01       	movw	r26, r6
 878:	5a 96       	adiw	r26, 0x1a	; 26
 87a:	fe 01       	movw	r30, r28
 87c:	31 96       	adiw	r30, 0x01	; 1
 87e:	9e 01       	movw	r18, r28
 880:	28 5f       	subi	r18, 0xF8	; 248
 882:	3f 4f       	sbci	r19, 0xFF	; 255
 884:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 886:	81 91       	ld	r24, Z+
 888:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 88a:	88 81       	ld	r24, Y
 88c:	88 23       	and	r24, r24
 88e:	19 f0       	breq	.+6      	; 0x896 <xTaskGenericCreate+0x92>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 890:	e2 17       	cp	r30, r18
 892:	f3 07       	cpc	r31, r19
 894:	b9 f7       	brne	.-18     	; 0x884 <xTaskGenericCreate+0x80>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 896:	f3 01       	movw	r30, r6
 898:	10 a2       	std	Z+32, r1	; 0x20
 89a:	10 2f       	mov	r17, r16
 89c:	04 30       	cpi	r16, 0x04	; 4
 89e:	08 f0       	brcs	.+2      	; 0x8a2 <xTaskGenericCreate+0x9e>
 8a0:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8a2:	f3 01       	movw	r30, r6
 8a4:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8a6:	e3 01       	movw	r28, r6
 8a8:	22 96       	adiw	r28, 0x02	; 2
 8aa:	ce 01       	movw	r24, r28
 8ac:	0e 94 4e 03 	call	0x69c	; 0x69c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8b0:	c3 01       	movw	r24, r6
 8b2:	0c 96       	adiw	r24, 0x0c	; 12
 8b4:	0e 94 4e 03 	call	0x69c	; 0x69c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8b8:	f3 01       	movw	r30, r6
 8ba:	60 86       	std	Z+8, r6	; 0x08
 8bc:	71 86       	std	Z+9, r7	; 0x09

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8be:	84 e0       	ldi	r24, 0x04	; 4
 8c0:	90 e0       	ldi	r25, 0x00	; 0
 8c2:	81 1b       	sub	r24, r17
 8c4:	91 09       	sbc	r25, r1
 8c6:	84 87       	std	Z+12, r24	; 0x0c
 8c8:	95 87       	std	Z+13, r25	; 0x0d
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8ca:	62 8a       	std	Z+18, r6	; 0x12
 8cc:	73 8a       	std	Z+19, r7	; 0x13
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8ce:	a2 01       	movw	r20, r4
 8d0:	b4 01       	movw	r22, r8
 8d2:	c5 01       	movw	r24, r10
 8d4:	0e 94 96 01 	call	0x32c	; 0x32c <pxPortInitialiseStack>
 8d8:	f3 01       	movw	r30, r6
 8da:	80 83       	st	Z, r24
 8dc:	91 83       	std	Z+1, r25	; 0x01
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8de:	e1 14       	cp	r14, r1
 8e0:	f1 04       	cpc	r15, r1
 8e2:	19 f0       	breq	.+6      	; 0x8ea <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8e4:	f7 01       	movw	r30, r14
 8e6:	60 82       	st	Z, r6
 8e8:	71 82       	std	Z+1, r7	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8ea:	0f b6       	in	r0, 0x3f	; 63
 8ec:	f8 94       	cli
 8ee:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 8f0:	80 91 75 23 	lds	r24, 0x2375
 8f4:	8f 5f       	subi	r24, 0xFF	; 255
 8f6:	80 93 75 23 	sts	0x2375, r24
			if( pxCurrentTCB == NULL )
 8fa:	80 91 b9 23 	lds	r24, 0x23B9
 8fe:	90 91 ba 23 	lds	r25, 0x23BA
 902:	89 2b       	or	r24, r25
 904:	89 f5       	brne	.+98     	; 0x968 <xTaskGenericCreate+0x164>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 906:	60 92 b9 23 	sts	0x23B9, r6
 90a:	70 92 ba 23 	sts	0x23BA, r7

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 90e:	80 91 75 23 	lds	r24, 0x2375
 912:	81 30       	cpi	r24, 0x01	; 1
 914:	c1 f5       	brne	.+112    	; 0x986 <xTaskGenericCreate+0x182>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 916:	85 e9       	ldi	r24, 0x95	; 149
 918:	93 e2       	ldi	r25, 0x23	; 35
 91a:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
 91e:	8e e9       	ldi	r24, 0x9E	; 158
 920:	93 e2       	ldi	r25, 0x23	; 35
 922:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
 926:	87 ea       	ldi	r24, 0xA7	; 167
 928:	93 e2       	ldi	r25, 0x23	; 35
 92a:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
 92e:	80 eb       	ldi	r24, 0xB0	; 176
 930:	93 e2       	ldi	r25, 0x23	; 35
 932:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 936:	8c e8       	ldi	r24, 0x8C	; 140
 938:	93 e2       	ldi	r25, 0x23	; 35
 93a:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 93e:	83 e8       	ldi	r24, 0x83	; 131
 940:	93 e2       	ldi	r25, 0x23	; 35
 942:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 946:	86 e7       	ldi	r24, 0x76	; 118
 948:	93 e2       	ldi	r25, 0x23	; 35
 94a:	0e 94 40 03 	call	0x680	; 0x680 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 94e:	8c e8       	ldi	r24, 0x8C	; 140
 950:	93 e2       	ldi	r25, 0x23	; 35
 952:	80 93 81 23 	sts	0x2381, r24
 956:	90 93 82 23 	sts	0x2382, r25
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 95a:	83 e8       	ldi	r24, 0x83	; 131
 95c:	93 e2       	ldi	r25, 0x23	; 35
 95e:	80 93 7f 23 	sts	0x237F, r24
 962:	90 93 80 23 	sts	0x2380, r25
 966:	0f c0       	rjmp	.+30     	; 0x986 <xTaskGenericCreate+0x182>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 968:	80 91 71 23 	lds	r24, 0x2371
 96c:	81 11       	cpse	r24, r1
 96e:	0b c0       	rjmp	.+22     	; 0x986 <xTaskGenericCreate+0x182>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 970:	e0 91 b9 23 	lds	r30, 0x23B9
 974:	f0 91 ba 23 	lds	r31, 0x23BA
 978:	86 89       	ldd	r24, Z+22	; 0x16
 97a:	08 17       	cp	r16, r24
 97c:	20 f0       	brcs	.+8      	; 0x986 <xTaskGenericCreate+0x182>
					{
						pxCurrentTCB = pxNewTCB;
 97e:	60 92 b9 23 	sts	0x23B9, r6
 982:	70 92 ba 23 	sts	0x23BA, r7
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 986:	80 91 6d 23 	lds	r24, 0x236D
 98a:	8f 5f       	subi	r24, 0xFF	; 255
 98c:	80 93 6d 23 	sts	0x236D, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 990:	f3 01       	movw	r30, r6
 992:	86 89       	ldd	r24, Z+22	; 0x16
 994:	90 91 72 23 	lds	r25, 0x2372
 998:	98 17       	cp	r25, r24
 99a:	10 f4       	brcc	.+4      	; 0x9a0 <xTaskGenericCreate+0x19c>
 99c:	80 93 72 23 	sts	0x2372, r24
 9a0:	90 e0       	ldi	r25, 0x00	; 0
 9a2:	9c 01       	movw	r18, r24
 9a4:	22 0f       	add	r18, r18
 9a6:	33 1f       	adc	r19, r19
 9a8:	22 0f       	add	r18, r18
 9aa:	33 1f       	adc	r19, r19
 9ac:	22 0f       	add	r18, r18
 9ae:	33 1f       	adc	r19, r19
 9b0:	82 0f       	add	r24, r18
 9b2:	93 1f       	adc	r25, r19
 9b4:	be 01       	movw	r22, r28
 9b6:	8b 56       	subi	r24, 0x6B	; 107
 9b8:	9c 4d       	sbci	r25, 0xDC	; 220
 9ba:	0e 94 52 03 	call	0x6a4	; 0x6a4 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 9be:	0f 90       	pop	r0
 9c0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 9c2:	80 91 71 23 	lds	r24, 0x2371
 9c6:	88 23       	and	r24, r24
 9c8:	59 f0       	breq	.+22     	; 0x9e0 <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 9ca:	e0 91 b9 23 	lds	r30, 0x23B9
 9ce:	f0 91 ba 23 	lds	r31, 0x23BA
 9d2:	86 89       	ldd	r24, Z+22	; 0x16
 9d4:	80 17       	cp	r24, r16
 9d6:	30 f4       	brcc	.+12     	; 0x9e4 <xTaskGenericCreate+0x1e0>
			{
				taskYIELD_IF_USING_PREEMPTION();
 9d8:	0e 94 46 02 	call	0x48c	; 0x48c <vPortYield>
 9dc:	81 e0       	ldi	r24, 0x01	; 1
 9de:	09 c0       	rjmp	.+18     	; 0x9f2 <xTaskGenericCreate+0x1ee>
 9e0:	81 e0       	ldi	r24, 0x01	; 1
 9e2:	07 c0       	rjmp	.+14     	; 0x9f2 <xTaskGenericCreate+0x1ee>
 9e4:	81 e0       	ldi	r24, 0x01	; 1
 9e6:	05 c0       	rjmp	.+10     	; 0x9f2 <xTaskGenericCreate+0x1ee>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 9e8:	fc 01       	movw	r30, r24
 9ea:	c7 8a       	std	Z+23, r12	; 0x17
 9ec:	d0 8e       	std	Z+24, r13	; 0x18
 9ee:	36 cf       	rjmp	.-404    	; 0x85c <xTaskGenericCreate+0x58>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 9f0:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 9f2:	df 91       	pop	r29
 9f4:	cf 91       	pop	r28
 9f6:	1f 91       	pop	r17
 9f8:	0f 91       	pop	r16
 9fa:	ff 90       	pop	r15
 9fc:	ef 90       	pop	r14
 9fe:	df 90       	pop	r13
 a00:	cf 90       	pop	r12
 a02:	bf 90       	pop	r11
 a04:	af 90       	pop	r10
 a06:	9f 90       	pop	r9
 a08:	8f 90       	pop	r8
 a0a:	7f 90       	pop	r7
 a0c:	6f 90       	pop	r6
 a0e:	5f 90       	pop	r5
 a10:	4f 90       	pop	r4
 a12:	08 95       	ret

00000a14 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 a14:	af 92       	push	r10
 a16:	bf 92       	push	r11
 a18:	cf 92       	push	r12
 a1a:	df 92       	push	r13
 a1c:	ef 92       	push	r14
 a1e:	ff 92       	push	r15
 a20:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 a22:	a1 2c       	mov	r10, r1
 a24:	b1 2c       	mov	r11, r1
 a26:	c1 2c       	mov	r12, r1
 a28:	d1 2c       	mov	r13, r1
 a2a:	e1 2c       	mov	r14, r1
 a2c:	f1 2c       	mov	r15, r1
 a2e:	00 e0       	ldi	r16, 0x00	; 0
 a30:	20 e0       	ldi	r18, 0x00	; 0
 a32:	30 e0       	ldi	r19, 0x00	; 0
 a34:	45 e5       	ldi	r20, 0x55	; 85
 a36:	50 e0       	ldi	r21, 0x00	; 0
 a38:	6b e0       	ldi	r22, 0x0B	; 11
 a3a:	70 e2       	ldi	r23, 0x20	; 32
 a3c:	8a ec       	ldi	r24, 0xCA	; 202
 a3e:	93 e0       	ldi	r25, 0x03	; 3
 a40:	0e 94 02 04 	call	0x804	; 0x804 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 a44:	81 30       	cpi	r24, 0x01	; 1
 a46:	49 f4       	brne	.+18     	; 0xa5a <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 a48:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 a4a:	80 93 71 23 	sts	0x2371, r24
		xTickCount = ( TickType_t ) 0U;
 a4e:	10 92 73 23 	sts	0x2373, r1
 a52:	10 92 74 23 	sts	0x2374, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 a56:	0e 94 04 02 	call	0x408	; 0x408 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 a5a:	0f 91       	pop	r16
 a5c:	ff 90       	pop	r15
 a5e:	ef 90       	pop	r14
 a60:	df 90       	pop	r13
 a62:	cf 90       	pop	r12
 a64:	bf 90       	pop	r11
 a66:	af 90       	pop	r10
 a68:	08 95       	ret

00000a6a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 a6a:	80 91 6c 23 	lds	r24, 0x236C
 a6e:	8f 5f       	subi	r24, 0xFF	; 255
 a70:	80 93 6c 23 	sts	0x236C, r24
 a74:	08 95       	ret

00000a76 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 a76:	df 92       	push	r13
 a78:	ef 92       	push	r14
 a7a:	ff 92       	push	r15
 a7c:	0f 93       	push	r16
 a7e:	1f 93       	push	r17
 a80:	cf 93       	push	r28
 a82:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a84:	80 91 6c 23 	lds	r24, 0x236C
 a88:	81 11       	cpse	r24, r1
 a8a:	b6 c0       	rjmp	.+364    	; 0xbf8 <xTaskIncrementTick+0x182>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 a8c:	80 91 73 23 	lds	r24, 0x2373
 a90:	90 91 74 23 	lds	r25, 0x2374
 a94:	01 96       	adiw	r24, 0x01	; 1
 a96:	80 93 73 23 	sts	0x2373, r24
 a9a:	90 93 74 23 	sts	0x2374, r25

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 a9e:	e0 90 73 23 	lds	r14, 0x2373
 aa2:	f0 90 74 23 	lds	r15, 0x2374

			if( xConstTickCount == ( TickType_t ) 0U )
 aa6:	e1 14       	cp	r14, r1
 aa8:	f1 04       	cpc	r15, r1
 aaa:	99 f5       	brne	.+102    	; 0xb12 <xTaskIncrementTick+0x9c>
			{
				taskSWITCH_DELAYED_LISTS();
 aac:	80 91 81 23 	lds	r24, 0x2381
 ab0:	90 91 82 23 	lds	r25, 0x2382
 ab4:	20 91 7f 23 	lds	r18, 0x237F
 ab8:	30 91 80 23 	lds	r19, 0x2380
 abc:	20 93 81 23 	sts	0x2381, r18
 ac0:	30 93 82 23 	sts	0x2382, r19
 ac4:	80 93 7f 23 	sts	0x237F, r24
 ac8:	90 93 80 23 	sts	0x2380, r25
 acc:	80 91 6e 23 	lds	r24, 0x236E
 ad0:	8f 5f       	subi	r24, 0xFF	; 255
 ad2:	80 93 6e 23 	sts	0x236E, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 ad6:	e0 91 81 23 	lds	r30, 0x2381
 ada:	f0 91 82 23 	lds	r31, 0x2382
 ade:	80 81       	ld	r24, Z
 ae0:	81 11       	cpse	r24, r1
 ae2:	07 c0       	rjmp	.+14     	; 0xaf2 <xTaskIncrementTick+0x7c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 ae4:	8f ef       	ldi	r24, 0xFF	; 255
 ae6:	9f ef       	ldi	r25, 0xFF	; 255
 ae8:	80 93 00 20 	sts	0x2000, r24
 aec:	90 93 01 20 	sts	0x2001, r25
 af0:	10 c0       	rjmp	.+32     	; 0xb12 <xTaskIncrementTick+0x9c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 af2:	e0 91 81 23 	lds	r30, 0x2381
 af6:	f0 91 82 23 	lds	r31, 0x2382
 afa:	05 80       	ldd	r0, Z+5	; 0x05
 afc:	f6 81       	ldd	r31, Z+6	; 0x06
 afe:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 b00:	06 80       	ldd	r0, Z+6	; 0x06
 b02:	f7 81       	ldd	r31, Z+7	; 0x07
 b04:	e0 2d       	mov	r30, r0
 b06:	82 81       	ldd	r24, Z+2	; 0x02
 b08:	93 81       	ldd	r25, Z+3	; 0x03
 b0a:	80 93 00 20 	sts	0x2000, r24
 b0e:	90 93 01 20 	sts	0x2001, r25

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 b12:	80 91 00 20 	lds	r24, 0x2000
 b16:	90 91 01 20 	lds	r25, 0x2001
 b1a:	e8 16       	cp	r14, r24
 b1c:	f9 06       	cpc	r15, r25
 b1e:	10 f4       	brcc	.+4      	; 0xb24 <xTaskIncrementTick+0xae>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 b20:	d1 2c       	mov	r13, r1
 b22:	52 c0       	rjmp	.+164    	; 0xbc8 <xTaskIncrementTick+0x152>
 b24:	d1 2c       	mov	r13, r1
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 b26:	e0 91 81 23 	lds	r30, 0x2381
 b2a:	f0 91 82 23 	lds	r31, 0x2382
 b2e:	90 81       	ld	r25, Z
 b30:	91 11       	cpse	r25, r1
 b32:	07 c0       	rjmp	.+14     	; 0xb42 <xTaskIncrementTick+0xcc>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 b34:	8f ef       	ldi	r24, 0xFF	; 255
 b36:	9f ef       	ldi	r25, 0xFF	; 255
 b38:	80 93 00 20 	sts	0x2000, r24
 b3c:	90 93 01 20 	sts	0x2001, r25
						break;
 b40:	43 c0       	rjmp	.+134    	; 0xbc8 <xTaskIncrementTick+0x152>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 b42:	e0 91 81 23 	lds	r30, 0x2381
 b46:	f0 91 82 23 	lds	r31, 0x2382
 b4a:	05 80       	ldd	r0, Z+5	; 0x05
 b4c:	f6 81       	ldd	r31, Z+6	; 0x06
 b4e:	e0 2d       	mov	r30, r0
 b50:	c6 81       	ldd	r28, Z+6	; 0x06
 b52:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 b54:	2a 81       	ldd	r18, Y+2	; 0x02
 b56:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 b58:	e2 16       	cp	r14, r18
 b5a:	f3 06       	cpc	r15, r19
 b5c:	28 f4       	brcc	.+10     	; 0xb68 <xTaskIncrementTick+0xf2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 b5e:	20 93 00 20 	sts	0x2000, r18
 b62:	30 93 01 20 	sts	0x2001, r19
							break;
 b66:	30 c0       	rjmp	.+96     	; 0xbc8 <xTaskIncrementTick+0x152>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 b68:	8e 01       	movw	r16, r28
 b6a:	0e 5f       	subi	r16, 0xFE	; 254
 b6c:	1f 4f       	sbci	r17, 0xFF	; 255
 b6e:	c8 01       	movw	r24, r16
 b70:	0e 94 a4 03 	call	0x748	; 0x748 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 b74:	8c 89       	ldd	r24, Y+20	; 0x14
 b76:	9d 89       	ldd	r25, Y+21	; 0x15
 b78:	89 2b       	or	r24, r25
 b7a:	21 f0       	breq	.+8      	; 0xb84 <xTaskIncrementTick+0x10e>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 b7c:	ce 01       	movw	r24, r28
 b7e:	0c 96       	adiw	r24, 0x0c	; 12
 b80:	0e 94 a4 03 	call	0x748	; 0x748 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 b84:	2e 89       	ldd	r18, Y+22	; 0x16
 b86:	80 91 72 23 	lds	r24, 0x2372
 b8a:	82 17       	cp	r24, r18
 b8c:	10 f4       	brcc	.+4      	; 0xb92 <xTaskIncrementTick+0x11c>
 b8e:	20 93 72 23 	sts	0x2372, r18
 b92:	30 e0       	ldi	r19, 0x00	; 0
 b94:	c9 01       	movw	r24, r18
 b96:	88 0f       	add	r24, r24
 b98:	99 1f       	adc	r25, r25
 b9a:	88 0f       	add	r24, r24
 b9c:	99 1f       	adc	r25, r25
 b9e:	88 0f       	add	r24, r24
 ba0:	99 1f       	adc	r25, r25
 ba2:	82 0f       	add	r24, r18
 ba4:	93 1f       	adc	r25, r19
 ba6:	b8 01       	movw	r22, r16
 ba8:	8b 56       	subi	r24, 0x6B	; 107
 baa:	9c 4d       	sbci	r25, 0xDC	; 220
 bac:	0e 94 52 03 	call	0x6a4	; 0x6a4 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 bb0:	e0 91 b9 23 	lds	r30, 0x23B9
 bb4:	f0 91 ba 23 	lds	r31, 0x23BA
 bb8:	9e 89       	ldd	r25, Y+22	; 0x16
 bba:	86 89       	ldd	r24, Z+22	; 0x16
 bbc:	98 17       	cp	r25, r24
 bbe:	08 f4       	brcc	.+2      	; 0xbc2 <xTaskIncrementTick+0x14c>
 bc0:	b2 cf       	rjmp	.-156    	; 0xb26 <xTaskIncrementTick+0xb0>
							{
								xSwitchRequired = pdTRUE;
 bc2:	dd 24       	eor	r13, r13
 bc4:	d3 94       	inc	r13
 bc6:	af cf       	rjmp	.-162    	; 0xb26 <xTaskIncrementTick+0xb0>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 bc8:	e0 91 b9 23 	lds	r30, 0x23B9
 bcc:	f0 91 ba 23 	lds	r31, 0x23BA
 bd0:	86 89       	ldd	r24, Z+22	; 0x16
 bd2:	90 e0       	ldi	r25, 0x00	; 0
 bd4:	fc 01       	movw	r30, r24
 bd6:	ee 0f       	add	r30, r30
 bd8:	ff 1f       	adc	r31, r31
 bda:	ee 0f       	add	r30, r30
 bdc:	ff 1f       	adc	r31, r31
 bde:	ee 0f       	add	r30, r30
 be0:	ff 1f       	adc	r31, r31
 be2:	8e 0f       	add	r24, r30
 be4:	9f 1f       	adc	r25, r31
 be6:	fc 01       	movw	r30, r24
 be8:	eb 56       	subi	r30, 0x6B	; 107
 bea:	fc 4d       	sbci	r31, 0xDC	; 220
 bec:	80 81       	ld	r24, Z
 bee:	82 30       	cpi	r24, 0x02	; 2
 bf0:	48 f0       	brcs	.+18     	; 0xc04 <xTaskIncrementTick+0x18e>
			{
				xSwitchRequired = pdTRUE;
 bf2:	dd 24       	eor	r13, r13
 bf4:	d3 94       	inc	r13
 bf6:	06 c0       	rjmp	.+12     	; 0xc04 <xTaskIncrementTick+0x18e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 bf8:	80 91 70 23 	lds	r24, 0x2370
 bfc:	8f 5f       	subi	r24, 0xFF	; 255
 bfe:	80 93 70 23 	sts	0x2370, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 c02:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 c04:	80 91 6f 23 	lds	r24, 0x236F
 c08:	88 23       	and	r24, r24
 c0a:	11 f0       	breq	.+4      	; 0xc10 <xTaskIncrementTick+0x19a>
		{
			xSwitchRequired = pdTRUE;
 c0c:	dd 24       	eor	r13, r13
 c0e:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 c10:	8d 2d       	mov	r24, r13
 c12:	df 91       	pop	r29
 c14:	cf 91       	pop	r28
 c16:	1f 91       	pop	r17
 c18:	0f 91       	pop	r16
 c1a:	ff 90       	pop	r15
 c1c:	ef 90       	pop	r14
 c1e:	df 90       	pop	r13
 c20:	08 95       	ret

00000c22 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 c22:	df 92       	push	r13
 c24:	ef 92       	push	r14
 c26:	ff 92       	push	r15
 c28:	0f 93       	push	r16
 c2a:	1f 93       	push	r17
 c2c:	cf 93       	push	r28
 c2e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 c30:	0f b6       	in	r0, 0x3f	; 63
 c32:	f8 94       	cli
 c34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 c36:	80 91 6c 23 	lds	r24, 0x236C
 c3a:	81 50       	subi	r24, 0x01	; 1
 c3c:	80 93 6c 23 	sts	0x236C, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 c40:	80 91 6c 23 	lds	r24, 0x236C
 c44:	81 11       	cpse	r24, r1
 c46:	62 c0       	rjmp	.+196    	; 0xd0c <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 c48:	80 91 75 23 	lds	r24, 0x2375
 c4c:	81 11       	cpse	r24, r1
 c4e:	33 c0       	rjmp	.+102    	; 0xcb6 <xTaskResumeAll+0x94>
 c50:	60 c0       	rjmp	.+192    	; 0xd12 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 c52:	d7 01       	movw	r26, r14
 c54:	15 96       	adiw	r26, 0x05	; 5
 c56:	ed 91       	ld	r30, X+
 c58:	fc 91       	ld	r31, X
 c5a:	16 97       	sbiw	r26, 0x06	; 6
 c5c:	c6 81       	ldd	r28, Z+6	; 0x06
 c5e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 c60:	ce 01       	movw	r24, r28
 c62:	0c 96       	adiw	r24, 0x0c	; 12
 c64:	0e 94 a4 03 	call	0x748	; 0x748 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 c68:	8e 01       	movw	r16, r28
 c6a:	0e 5f       	subi	r16, 0xFE	; 254
 c6c:	1f 4f       	sbci	r17, 0xFF	; 255
 c6e:	c8 01       	movw	r24, r16
 c70:	0e 94 a4 03 	call	0x748	; 0x748 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 c74:	2e 89       	ldd	r18, Y+22	; 0x16
 c76:	80 91 72 23 	lds	r24, 0x2372
 c7a:	82 17       	cp	r24, r18
 c7c:	10 f4       	brcc	.+4      	; 0xc82 <xTaskResumeAll+0x60>
 c7e:	20 93 72 23 	sts	0x2372, r18
 c82:	30 e0       	ldi	r19, 0x00	; 0
 c84:	c9 01       	movw	r24, r18
 c86:	88 0f       	add	r24, r24
 c88:	99 1f       	adc	r25, r25
 c8a:	88 0f       	add	r24, r24
 c8c:	99 1f       	adc	r25, r25
 c8e:	88 0f       	add	r24, r24
 c90:	99 1f       	adc	r25, r25
 c92:	82 0f       	add	r24, r18
 c94:	93 1f       	adc	r25, r19
 c96:	b8 01       	movw	r22, r16
 c98:	8b 56       	subi	r24, 0x6B	; 107
 c9a:	9c 4d       	sbci	r25, 0xDC	; 220
 c9c:	0e 94 52 03 	call	0x6a4	; 0x6a4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 ca0:	e0 91 b9 23 	lds	r30, 0x23B9
 ca4:	f0 91 ba 23 	lds	r31, 0x23BA
 ca8:	9e 89       	ldd	r25, Y+22	; 0x16
 caa:	86 89       	ldd	r24, Z+22	; 0x16
 cac:	98 17       	cp	r25, r24
 cae:	58 f0       	brcs	.+22     	; 0xcc6 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
 cb0:	d0 92 6f 23 	sts	0x236F, r13
 cb4:	08 c0       	rjmp	.+16     	; 0xcc6 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 cb6:	0f 2e       	mov	r0, r31
 cb8:	f6 e7       	ldi	r31, 0x76	; 118
 cba:	ef 2e       	mov	r14, r31
 cbc:	f3 e2       	ldi	r31, 0x23	; 35
 cbe:	ff 2e       	mov	r15, r31
 cc0:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 cc2:	dd 24       	eor	r13, r13
 cc4:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 cc6:	f7 01       	movw	r30, r14
 cc8:	80 81       	ld	r24, Z
 cca:	81 11       	cpse	r24, r1
 ccc:	c2 cf       	rjmp	.-124    	; 0xc52 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 cce:	80 91 70 23 	lds	r24, 0x2370
 cd2:	88 23       	and	r24, r24
 cd4:	99 f0       	breq	.+38     	; 0xcfc <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 cd6:	80 91 70 23 	lds	r24, 0x2370
 cda:	88 23       	and	r24, r24
 cdc:	79 f0       	breq	.+30     	; 0xcfc <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 cde:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 ce0:	0e 94 3b 05 	call	0xa76	; 0xa76 <xTaskIncrementTick>
 ce4:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 ce6:	c0 93 6f 23 	sts	0x236F, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 cea:	80 91 70 23 	lds	r24, 0x2370
 cee:	81 50       	subi	r24, 0x01	; 1
 cf0:	80 93 70 23 	sts	0x2370, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 cf4:	80 91 70 23 	lds	r24, 0x2370
 cf8:	81 11       	cpse	r24, r1
 cfa:	f2 cf       	rjmp	.-28     	; 0xce0 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 cfc:	80 91 6f 23 	lds	r24, 0x236F
 d00:	81 30       	cpi	r24, 0x01	; 1
 d02:	31 f4       	brne	.+12     	; 0xd10 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 d04:	0e 94 46 02 	call	0x48c	; 0x48c <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 d08:	81 e0       	ldi	r24, 0x01	; 1
 d0a:	03 c0       	rjmp	.+6      	; 0xd12 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 d0c:	80 e0       	ldi	r24, 0x00	; 0
 d0e:	01 c0       	rjmp	.+2      	; 0xd12 <xTaskResumeAll+0xf0>
 d10:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 d12:	0f 90       	pop	r0
 d14:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 d16:	df 91       	pop	r29
 d18:	cf 91       	pop	r28
 d1a:	1f 91       	pop	r17
 d1c:	0f 91       	pop	r16
 d1e:	ff 90       	pop	r15
 d20:	ef 90       	pop	r14
 d22:	df 90       	pop	r13
 d24:	08 95       	ret

00000d26 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 d26:	cf 93       	push	r28
 d28:	df 93       	push	r29
 d2a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 d2c:	89 2b       	or	r24, r25
 d2e:	b1 f0       	breq	.+44     	; 0xd5c <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 d30:	0e 94 35 05 	call	0xa6a	; 0xa6a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 d34:	80 91 73 23 	lds	r24, 0x2373
 d38:	90 91 74 23 	lds	r25, 0x2374
 d3c:	c8 0f       	add	r28, r24
 d3e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 d40:	80 91 b9 23 	lds	r24, 0x23B9
 d44:	90 91 ba 23 	lds	r25, 0x23BA
 d48:	02 96       	adiw	r24, 0x02	; 2
 d4a:	0e 94 a4 03 	call	0x748	; 0x748 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 d4e:	ce 01       	movw	r24, r28
 d50:	0e 94 cb 03 	call	0x796	; 0x796 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 d54:	0e 94 11 06 	call	0xc22	; 0xc22 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 d58:	81 11       	cpse	r24, r1
 d5a:	02 c0       	rjmp	.+4      	; 0xd60 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 d5c:	0e 94 46 02 	call	0x48c	; 0x48c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 d60:	df 91       	pop	r29
 d62:	cf 91       	pop	r28
 d64:	08 95       	ret

00000d66 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d66:	80 91 6c 23 	lds	r24, 0x236C
 d6a:	88 23       	and	r24, r24
 d6c:	21 f0       	breq	.+8      	; 0xd76 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d6e:	81 e0       	ldi	r24, 0x01	; 1
 d70:	80 93 6f 23 	sts	0x236F, r24
 d74:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d76:	10 92 6f 23 	sts	0x236F, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d7a:	80 91 72 23 	lds	r24, 0x2372
 d7e:	90 e0       	ldi	r25, 0x00	; 0
 d80:	fc 01       	movw	r30, r24
 d82:	ee 0f       	add	r30, r30
 d84:	ff 1f       	adc	r31, r31
 d86:	ee 0f       	add	r30, r30
 d88:	ff 1f       	adc	r31, r31
 d8a:	ee 0f       	add	r30, r30
 d8c:	ff 1f       	adc	r31, r31
 d8e:	8e 0f       	add	r24, r30
 d90:	9f 1f       	adc	r25, r31
 d92:	fc 01       	movw	r30, r24
 d94:	eb 56       	subi	r30, 0x6B	; 107
 d96:	fc 4d       	sbci	r31, 0xDC	; 220
 d98:	80 81       	ld	r24, Z
 d9a:	81 11       	cpse	r24, r1
 d9c:	17 c0       	rjmp	.+46     	; 0xdcc <vTaskSwitchContext+0x66>
 d9e:	80 91 72 23 	lds	r24, 0x2372
 da2:	81 50       	subi	r24, 0x01	; 1
 da4:	80 93 72 23 	sts	0x2372, r24
 da8:	80 91 72 23 	lds	r24, 0x2372
 dac:	90 e0       	ldi	r25, 0x00	; 0
 dae:	fc 01       	movw	r30, r24
 db0:	ee 0f       	add	r30, r30
 db2:	ff 1f       	adc	r31, r31
 db4:	ee 0f       	add	r30, r30
 db6:	ff 1f       	adc	r31, r31
 db8:	ee 0f       	add	r30, r30
 dba:	ff 1f       	adc	r31, r31
 dbc:	8e 0f       	add	r24, r30
 dbe:	9f 1f       	adc	r25, r31
 dc0:	fc 01       	movw	r30, r24
 dc2:	eb 56       	subi	r30, 0x6B	; 107
 dc4:	fc 4d       	sbci	r31, 0xDC	; 220
 dc6:	80 81       	ld	r24, Z
 dc8:	88 23       	and	r24, r24
 dca:	49 f3       	breq	.-46     	; 0xd9e <vTaskSwitchContext+0x38>
 dcc:	80 91 72 23 	lds	r24, 0x2372
 dd0:	90 e0       	ldi	r25, 0x00	; 0
 dd2:	9c 01       	movw	r18, r24
 dd4:	22 0f       	add	r18, r18
 dd6:	33 1f       	adc	r19, r19
 dd8:	22 0f       	add	r18, r18
 dda:	33 1f       	adc	r19, r19
 ddc:	22 0f       	add	r18, r18
 dde:	33 1f       	adc	r19, r19
 de0:	28 0f       	add	r18, r24
 de2:	39 1f       	adc	r19, r25
 de4:	d9 01       	movw	r26, r18
 de6:	ab 56       	subi	r26, 0x6B	; 107
 de8:	bc 4d       	sbci	r27, 0xDC	; 220
 dea:	11 96       	adiw	r26, 0x01	; 1
 dec:	ed 91       	ld	r30, X+
 dee:	fc 91       	ld	r31, X
 df0:	12 97       	sbiw	r26, 0x02	; 2
 df2:	02 80       	ldd	r0, Z+2	; 0x02
 df4:	f3 81       	ldd	r31, Z+3	; 0x03
 df6:	e0 2d       	mov	r30, r0
 df8:	11 96       	adiw	r26, 0x01	; 1
 dfa:	ed 93       	st	X+, r30
 dfc:	fc 93       	st	X, r31
 dfe:	12 97       	sbiw	r26, 0x02	; 2
 e00:	28 56       	subi	r18, 0x68	; 104
 e02:	3c 4d       	sbci	r19, 0xDC	; 220
 e04:	e2 17       	cp	r30, r18
 e06:	f3 07       	cpc	r31, r19
 e08:	29 f4       	brne	.+10     	; 0xe14 <vTaskSwitchContext+0xae>
 e0a:	22 81       	ldd	r18, Z+2	; 0x02
 e0c:	33 81       	ldd	r19, Z+3	; 0x03
 e0e:	fd 01       	movw	r30, r26
 e10:	21 83       	std	Z+1, r18	; 0x01
 e12:	32 83       	std	Z+2, r19	; 0x02
 e14:	fc 01       	movw	r30, r24
 e16:	ee 0f       	add	r30, r30
 e18:	ff 1f       	adc	r31, r31
 e1a:	ee 0f       	add	r30, r30
 e1c:	ff 1f       	adc	r31, r31
 e1e:	ee 0f       	add	r30, r30
 e20:	ff 1f       	adc	r31, r31
 e22:	8e 0f       	add	r24, r30
 e24:	9f 1f       	adc	r25, r31
 e26:	fc 01       	movw	r30, r24
 e28:	eb 56       	subi	r30, 0x6B	; 107
 e2a:	fc 4d       	sbci	r31, 0xDC	; 220
 e2c:	01 80       	ldd	r0, Z+1	; 0x01
 e2e:	f2 81       	ldd	r31, Z+2	; 0x02
 e30:	e0 2d       	mov	r30, r0
 e32:	86 81       	ldd	r24, Z+6	; 0x06
 e34:	97 81       	ldd	r25, Z+7	; 0x07
 e36:	80 93 b9 23 	sts	0x23B9, r24
 e3a:	90 93 ba 23 	sts	0x23BA, r25
 e3e:	08 95       	ret

00000e40 <_exit>:
 e40:	f8 94       	cli

00000e42 <__stop_program>:
 e42:	ff cf       	rjmp	.-2      	; 0xe42 <__stop_program>
